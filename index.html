<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Kibera's Flag Gauntlet</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Calligraffitti&display=swap" rel="stylesheet">

  <!--
    ============================================================================================
    SECTION: FONTS (Comic burst)
    ============================================================================================
    - Uses "Bazinga" if you host it next to index.html as Bazinga.woff2 / Bazinga.woff / Bazinga.ttf
    - Falls back to Google "Bangers" and system fonts if Bazinga isnâ€™t present.
  -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Bangers&display=swap" rel="stylesheet">
  <style>
    @font-face{
      font-family: "Bazinga";
      src:
        url("Bazinga.woff2") format("woff2"),
        url("Bazinga.woff") format("woff"),
        url("Bazinga.ttf") format("truetype");
      font-display: swap;
    }
  </style>

  <style>
    :root{
      --bg: #dfe8f4;
      --ink: #253041;
      --card: rgba(11,16,32,0.92);
      --cardBorder: rgba(0,0,0,0.18);

      --pillBg: rgba(255,255,255,0.10);

      --flagStageH: 340px;

      /* Messaging area: fixed layout so nothing jumps */
      --msgH: 320px;
      --iconColW: 150px;

      --brandBlueGrey: rgba(80, 110, 140, 0.42);

      /* =========================================================================================
         SECTION: TOP/BOTTOM FLAG BANDS (mirror targets)
         ========================================================================================= */
      --bandH: 210px; /* fixed band height to avoid vertical squish */
    }

    html, body { height: 100%; }
    body{
      margin: 0;
      background: var(--bg);
      color: var(--ink);
      min-height: 100vh;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      display:flex;
      flex-direction: column;
      overflow-x: hidden;
    }

    .main{
      flex: 1;
      display: grid;
      place-items: center;
      padding: 70px 14px 10px;
      position: relative;
      z-index: 2;
    }

    .wrap{
      width: min(980px, 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 14px;
      position: relative;
    }

    /* =========================================================================================
       SECTION: BRAND TITLE (MUST STAY Calligraffitti)
       ========================================================================================= */
    .brandAngle{
      position: absolute;
      left: -132px;
      top: 118px;
      transform: rotate(-45deg);
      transform-origin: left top;
      font-family: "Calligraffitti", "Snell Roundhand", "Apple Chancery", "Segoe Script", cursive;
      font-size: 46px;
      font-weight: 400;
      color: var(--brandBlueGrey);
      user-select: none;
      pointer-events: none;
      z-index: 10;
      line-height: 0.92;
      text-align: center;
      width: 250px;
    }

    .topbar{
      width: min(900px, 100%);
      display:flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: center;
      margin-bottom: 2px;
    }

    .pill{
      padding: 10px 14px;
      border-radius: 999px;
      background: var(--pillBg);
      border: 1px solid rgba(0,0,0,0.08);
      font-size: 18px;
      color: #0b1020;
      display:flex;
      align-items:center;
      gap: 10px;
      backdrop-filter: blur(6px);
      white-space: nowrap;
    }
    .pill b{ font-size: 20px; }

    .restartBtnTop{
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid rgba(0,0,0,0.12);
      background: rgba(0,0,0,0.06);
      color: #0b1020;
      cursor: pointer;
      font-size: 13px;
      white-space: nowrap;
      letter-spacing: 0.8px;
      font-weight: 900;
    }
    .restartBtnTop:hover{ background: rgba(0,0,0,0.10); }

    .card{
      width: min(900px, 100%);
      background: var(--card);
      border: 1px solid var(--cardBorder);
      border-radius: 18px;
      padding: 18px 18px 16px;
      color: #e9eefc;
      box-shadow: 0 18px 45px rgba(0,0,0,0.25);
      position: relative;
    }

    .questionTitle{
      text-align: center;
      margin: 6px 0 10px;
      font-size: 34px;
      letter-spacing: 0.3px;
      font-weight: 200;
      opacity: 0.95;
      font-family: "Helvetica Neue", Helvetica, Arial, system-ui, sans-serif;
    }

    .flagStage{
      height: var(--flagStageH);
      width: 100%;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 6px 0 12px;
      box-sizing: border-box;
    }
    /* =========================================================================================
       SECTION: FLAG IMAGE SIZE (keep as requested: 500x300 box)
       ========================================================================================= */
    .flag{
      width: 500px;
      height: 300px;
      object-fit: contain;
      border-radius: 14px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.04);
    }

    .controls{
      display:flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      margin-top: 0px;
    }
    .controlRow{
      width: min(520px, 92%);
      display:flex;
      align-items: stretch;
      gap: 10px;
    }

    .inputWrap{ flex: 1; position: relative; }
    input[type="text"]{
      width: 100%;
      padding: 16px 14px;
      font-size: 18px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.35);
      color: #e9eefc;
      outline: none;
      box-sizing: border-box;
    }
    input[type="text"]::placeholder{ color: rgba(233,238,252,0.65); }

    .btnCol{
      display:flex;
      gap: 10px;
      align-items: stretch;
    }

    button{
      padding: 12px 14px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(90,140,255,0.22);
      color: #e9eefc;
      cursor: pointer;
      min-width: 96px;
      font-size: 13px;
      font-weight: 900;
      letter-spacing: 0.9px;
    }
    button:hover{ background: rgba(90,140,255,0.33); }
    button:disabled{ opacity: 0.55; cursor: not-allowed; }

    /* Hint CTA: only below inputs; +15% font */
    .hintHotkeyLine{
      width: min(520px, 92%);
      text-align: left;
      font-size: 15px; /* 13px * 1.15 */
      color: rgba(233,238,252,0.70);
      margin-top: -2px;
      font-family: "Helvetica Neue", Helvetica, Arial, system-ui, sans-serif;
      font-weight: 300;
    }
    .hintHotkeyLine b{ color: rgba(233,238,252,0.92); font-weight: 650; }

    .suggestBox{
      position: absolute;
      left: 0; right: 0;
      top: calc(100% + 8px);
      background: rgba(14, 20, 40, 0.98);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 14px;
      box-shadow: 0 18px 45px rgba(0,0,0,0.45);
      overflow: hidden;
      z-index: 50;
      display: none;
      max-height: 320px;
      overflow-y: auto;
    }
    .sgItem{
      padding: 10px 12px;
      cursor: pointer;
      color: #e9eefc;
      border-top: 1px solid rgba(255,255,255,0.06);
      display:flex;
      justify-content: space-between;
      gap: 12px;
      align-items: center;
    }
    .sgItem:hover, .sgItem.active{ background: rgba(90,140,255,0.22); }
    .sgMeta{ font-size: 12px; opacity: 0.70; white-space: nowrap; }

    /* Messaging area: fixed layout so nothing jumps */
    .belowMsg{
      width: min(900px, 100%);
      height: var(--msgH);
      display: grid;
      place-items: center;
      overflow: hidden;
      z-index: 2;
      position: relative;
    }

    .msgGrid{
      width: min(900px, 100%);
      display: grid;
      grid-template-columns: var(--iconColW) minmax(0, 1fr);
      align-items: start;
      gap: 18px;
      padding: 0 6px;
      box-sizing: border-box;
    }

    .iconCol{
      display:flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      padding-top: 2px;
    }

    /* Icon area stays same size; content is SVG burst with TRANSPARENT background */
    .iconSq{
      width: 132px;
      height: 132px;
      border-radius: 18px;
      border: none;
      background: rgba(255,255,255,0.0);
      overflow: visible;
      display: grid;
      place-items: center;
      box-shadow: none;
    }
    .iconSq svg{ width: 100%; height: 100%; display:block; }

    .iconLabel{ display:none; } /* remove prior all-caps titles entirely */

    /* Messaging typography: slightly smaller (10%) */
    .msgText{
      text-align: left;
      line-height: 1.25;
      align-self: start;
      padding-top: 6px;
      font-family: "Helvetica Neue", Helvetica, Arial, system-ui, sans-serif;
      font-weight: 300;
    }
    .msgText .headline{
      font-size: 26px;   /* ~29 * 0.9 */
      margin: 0 0 10px;
      min-height: 36px;
      color: rgba(37,48,65,0.92);
      font-weight: 320;
    }
    .msgText .sub{
      font-size: 20px;   /* ~22 * 0.9 */
      opacity: 0.92;
      margin: 0;
      min-height: 96px;
      color: rgba(37,48,65,0.86);
      font-weight: 300;
    }
    /* Bold inside messages: lighten weight */
    .msgText b{ font-weight: 520; }
    .msgText a{
      color: rgba(30,80,170,0.95);
      text-decoration: underline;
      font-weight: 520;
    }

    .bottomArea{
      width: 100%;
      position: relative;
      z-index: 1;
    }

    .copyright{
      position: fixed;
      left: 0;
      width: 100%;
      bottom: 50px;
      text-align: center;
      color: rgba(37,48,65,0.75);
      font-size: 13px;
      letter-spacing: 0.3px;
      z-index: 3;
      pointer-events: none;
      font-family: "Helvetica Neue", Helvetica, Arial, system-ui, sans-serif;
      font-weight: 300;
    }

    /* =========================================================================================
       SECTION: FLAG BANDS (header + footer) â€” mirrored from ONE generated band
       - Header: solid at top, fades OUT as it approaches content (downward)
       - Footer: fades IN as it goes downward (same as before)
       ========================================================================================= */

    .flagBandHeader{
      position: fixed;
      left: 0;
      top: 0;
      width: 100vw;
      height: var(--bandH);
      z-index: 0;
      overflow: hidden;
      pointer-events: none;
    }
    .headerSvg{
      position:absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      opacity: 1;
      /* Solid at top -> fade to transparent at bottom (toward content) */
      mask-image: linear-gradient(
        to bottom,
        rgba(0,0,0,1.00) 0%,
        rgba(0,0,0,1.00) 55%,
        rgba(0,0,0,0.35) 78%,
        rgba(0,0,0,0.00) 100%
      );
    }

    /* Footer container begins after message; SVG itself is fixed-height and pinned to bottom to avoid squish */
    .flagFooter{
      position: fixed;
      left: 0;
      width: 100vw;
      bottom: 0;
      top: auto;           /* JS sets top */
      height: 0px;         /* JS sets height */
      z-index: 0;
      overflow: hidden;
      pointer-events: none;
      background: none;
    }
    .footerSvg{
      position:absolute;
      left: 0;
      bottom: 0;           /* pin to bottom */
      width: 100%;
      height: var(--bandH);/* fixed height == header band */
      opacity: 1;
      /* Fade-in as you move DOWN */
      mask-image: linear-gradient(
        to bottom,
        rgba(0,0,0,0.00) 0%,
        rgba(0,0,0,0.20) 18%,
        rgba(0,0,0,0.70) 52%,
        rgba(0,0,0,1.00) 78%,
        rgba(0,0,0,1.00) 100%
      );
    }

    .confettiLayer{
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 9999;
      display: none;
    }

    .roundOverlay{
      position: fixed;
      inset: 0;
      display: none;
      pointer-events: none;
      z-index: 10000;
      place-items: center;
      text-align: center;
    }
    .roundOverlay .big{
      font-family: "Bazinga","Bangers","Impact","Arial Black",system-ui,sans-serif;
      font-weight: 400;
      font-size: min(160px, 18vw);
      line-height: 0.95;
      color: rgba(11,16,32,0.92);
      padding: 0;
      border-radius: 0;
      background: none;
      border: none;
      text-shadow: 0 12px 30px rgba(0,0,0,0.25);
      transform-origin: 50% 75%;
    }

    @media (max-width: 900px){
      .brandAngle{ left: -122px; top: 130px; font-size: 40px; width: 230px; }
      .questionTitle{ font-size: 30px; }
      .iconSq{ width: 120px; height: 120px; }
      :root{ --iconColW: 140px; --msgH: 300px; --bandH: 190px; }
      .msgText .headline{ font-size: 24px; }
      .msgText .sub{ font-size: 19px; }
      .flag{ width: min(500px, 92%); height: auto; max-height: 300px; }
    }
    @media (max-width: 760px){
      :root{ --iconColW: 132px; --msgH: 290px; --bandH: 180px; }
      .pill{ font-size: 16px; }
      .pill b{ font-size: 18px; }
      .questionTitle{ font-size: 26px; }
      .brandAngle{ font-size: 34px; left: -110px; top: 140px; width: 210px; }
    }
  </style>
</head>

<body>
  <div class="confettiLayer" id="confettiLayer">
    <canvas id="confettiCanvas" style="width:100%;height:100%"></canvas>
  </div>

  <div class="roundOverlay" id="roundOverlay">
    <div class="big" id="roundOverlayText">ROUND 2!</div>
  </div>

  <!-- Header band -->
  <div class="flagBandHeader" aria-hidden="true">
    <svg id="headerSvg" class="headerSvg" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="none"></svg>
  </div>

  <div class="main">
    <div class="wrap">
      <div class="brandAngle">Kibera's<br/>Flag Gauntlet</div>

      <div class="topbar">
        <div class="pill">Round: <b id="roundNum">1</b> / <span id="roundTotal">?</span></div>
        <div class="pill">Flag: <b id="flagIndex">1</b> / <b id="flagsPerRound">10</b></div>
        <div class="pill">Tries left: <b id="triesLeft">3</b></div>
        <div class="pill">
          Score: <b id="score">0</b>
          <button class="restartBtnTop" id="restartBtnTop" title="Restart from Round 1">RESTART</button>
        </div>
      </div>

      <div class="card" id="card">
        <div class="questionTitle">What Country's Flag Is This?</div>

        <div class="flagStage">
          <img id="flagImg" class="flag" alt="Country flag" />
        </div>

        <div class="controls">
          <div class="controlRow">
            <div class="inputWrap">
              <input id="guessInput" type="text" placeholder="Type a country nameâ€¦" autocomplete="off" />
              <div id="suggestBox" class="suggestBox" role="listbox" aria-label="Country suggestions"></div>
            </div>

            <div class="btnCol">
              <button id="submitBtn">SUBMIT</button>
              <button id="skipBtn" title="Give up on this flag (0 points)">SKIP</button>
            </div>
          </div>

          <div class="hintHotkeyLine">
            Hit the period <b>&ldquo;.&rdquo;</b> key for a hint! Each hint costs a try
          </div>
        </div>
      </div>

      <div class="belowMsg" id="belowMsg"></div>
    </div>
  </div>

  <div class="bottomArea">
    <div class="copyright">Â© 2026 Kibera &amp; Co.</div>

    <!-- Footer band (mirrors header; positioned by JS after message module) -->
    <div class="flagFooter" id="flagFooter" aria-hidden="true">
      <svg id="footerSvg" class="footerSvg" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="none"></svg>
    </div>
  </div>

<script>
(() => {
  const FLAGS_PER_ROUND = 10;
  const TRIES_PER_FLAG = 3;

  const PAUSE_CORRECT_MS = 3000;
  const PAUSE_WRONG_MS   = 10000;

  // UI
  const roundNumEl = document.getElementById('roundNum');
  const roundTotalEl = document.getElementById('roundTotal');
  const flagIndexEl = document.getElementById('flagIndex');
  const flagsPerRoundEl = document.getElementById('flagsPerRound');
  const triesLeftEl = document.getElementById('triesLeft');
  const scoreEl = document.getElementById('score');

  const flagImg = document.getElementById('flagImg');
  const guessInput = document.getElementById('guessInput');
  const submitBtn = document.getElementById('submitBtn');
  const skipBtn = document.getElementById('skipBtn');
  const restartBtnTop = document.getElementById('restartBtnTop');

  const suggestBox = document.getElementById('suggestBox');
  const belowMsg = document.getElementById('belowMsg');

  const headerSvg = document.getElementById('headerSvg');
  const footerSvg = document.getElementById('footerSvg');
  const footerEl  = document.getElementById('flagFooter');

  const confettiLayer = document.getElementById('confettiLayer');
  const confettiCanvas = document.getElementById('confettiCanvas');
  const roundOverlay = document.getElementById('roundOverlay');
  const roundOverlayText = document.getElementById('roundOverlayText');

  // Game state
  let countries = [];
  let rounds = [];
  let roundIdx = 0;
  let flagIdx = 0;
  let triesLeft = TRIES_PER_FLAG;
  let score = 0;

  // Suggest state
  let activeSuggestionIndex = -1;
  let currentSuggestions = [];
  let lastRenderedQuery = "";

  let cca3ToCountry = new Map();

  function pick(arr){ return arr[Math.floor(Math.random() * arr.length)]; }

  function norm(s) {
    return String(s || '')
      .trim()
      .toLowerCase()
      .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
      .replace(/[^a-z0-9 ]/g, '')
      .replace(/\s+/g, ' ');
  }

  function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  function updateHUD() {
    roundNumEl.textContent = String(roundIdx + 1);
    roundTotalEl.textContent = String(rounds.length || '?');
    flagIndexEl.textContent = String(flagIdx + 1);
    flagsPerRoundEl.textContent = String(FLAGS_PER_ROUND);
    triesLeftEl.textContent = String(triesLeft);
    scoreEl.textContent = String(score);
  }

  function currentCountry() {
    return rounds?.[roundIdx]?.[flagIdx] || null;
  }

  function continentLabel(region, subregion) {
    const r = String(region || '').trim();
    const s = String(subregion || '').trim();
    if (!r) return 'Other';
    if (r === 'Americas') {
      if (s.includes('South')) return 'South America';
      if (s.includes('North')) return 'North America';
      if (s.includes('Caribbean')) return 'Caribbean';
      if (s.includes('Central')) return 'Central America';
      return 'Americas';
    }
    return r;
  }

  /* =============================================================================================
     SECTION: COMIC BURST ICON (Transparent background; 45Â° text; thinner outline)
     - Attempts to mimic the referenced halftone speech-bubble comic background style.
     - No added bgcolor; SVG background remains transparent.
     ============================================================================================= */
  function burstSVG(kind, text){
    // palettes per request
    const palettes = {
      // default: BAM style (light blue text, red/orange burst)
      neutral: { textFill:'#6EC6FF', textShadow:'#000000', burstA:'#FF3B30', burstB:'#FFB000', dots:'#000000' },
      // fail: yellow text, red/orange burst
      fail:    { textFill:'#FFD400', textShadow:'#000000', burstA:'#FF3B30', burstB:'#FFB000', dots:'#000000' },
      // success: green text, darker green burst with light green/yellow accents
      success: { textFill:'#26E07A', textShadow:'#000000', burstA:'#0E8B45', burstB:'#B7FF4A', dots:'#000000' },
      // hint: light blue text, darker blue / lighter blue/purple burst
      hint:    { textFill:'#7FD4FF', textShadow:'#000000', burstA:'#3A63FF', burstB:'#B08CFF', dots:'#000000' },
    };
    const p = palettes[kind] || palettes.neutral;

    // thinner outline (50% reduction vs prior)
    const outlineW = 3;

    // â€œspeech bubble / burstâ€ + halftone field behind (transparent background)
    return `
    <svg viewBox="0 0 140 140" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
      <defs>
        <radialGradient id="gBurst" cx="45%" cy="45%" r="70%">
          <stop offset="0%" stop-color="${p.burstB}" stop-opacity="0.95"/>
          <stop offset="100%" stop-color="${p.burstA}" stop-opacity="0.95"/>
        </radialGradient>

        <!-- halftone dot field -->
        <pattern id="dots" width="8" height="8" patternUnits="userSpaceOnUse">
          <circle cx="2.0" cy="2.0" r="1.2" fill="${p.dots}" opacity="0.22"/>
        </pattern>

        <filter id="soft" x="-20%" y="-20%" width="140%" height="140%">
          <feDropShadow dx="0" dy="6" stdDeviation="4" flood-color="rgba(0,0,0,0.25)"/>
        </filter>
      </defs>

      <!-- halftone behind burst (still transparent overall) -->
      <g opacity="1">
        <circle cx="92" cy="72" r="44" fill="url(#dots)" opacity="0.55"/>
      </g>

      <!-- burst shape (more realistic jagged) -->
      <path filter="url(#soft)"
        d="M70 12
           L83 30 L103 20 L98 42
           L126 44 L108 60
           L132 78 L104 78
           L112 106 L92 92
           L82 128 L70 108
           L56 132 L52 106
           L36 96 L32 120
           L22 92 L8 104
           L12 82 L0 74
           L16 62 L4 44
           L28 44 L24 22
           L44 30 L56 12
           Z"
        fill="url(#gBurst)"
        stroke="rgba(0,0,0,0.92)"
        stroke-width="${outlineW}"
        stroke-linejoin="round"/>

      <!-- inner highlight edge -->
      <path
        d="M70 22
           L80 36 L98 28 L94 44
           L116 46 L100 58
           L120 74 L98 74
           L104 96 L88 86
           L80 114 L70 98
           L60 114 L56 96
           L42 88 L38 104
           L30 86 L18 96
           L22 78 L12 72
           L26 62 L16 46
           L36 46 L34 28
           L52 36 L60 22
           Z"
        fill="none"
        stroke="rgba(255,255,255,0.35)"
        stroke-width="2"
        stroke-linejoin="round"
        opacity="0.55"/>

      <!-- angled text @ 45Â° -->
      <g transform="translate(70 72) rotate(-45)">
        <text x="0" y="10"
          text-anchor="middle"
          font-family="Bazinga, Bangers, Impact, Arial Black, system-ui"
          font-size="${text.length > 7 ? 34 : 40}"
          letter-spacing="1"
          fill="${p.textFill}"
          stroke="${p.textShadow}"
          stroke-width="6"
          paint-order="stroke"
          opacity="1">${text}</text>
      </g>
    </svg>`;
  }

  /* =============================================================================================
     SECTION: MESSAGE RENDERER (no icon labels; icon is the burst SVG)
     ============================================================================================= */
  function renderMsg(kind, headline, sub){
    const iconTextByKind = {
      neutral: "LET'S GO!",
      fail: "OH NAWR!",
      success: "BOOM!",
      hint: "PSSSST!"
    };
    const iconText = iconTextByKind[kind] || "LET'S GO!";

    belowMsg.innerHTML = `
      <div class="msgGrid">
        <div class="iconCol">
          <div class="iconSq" aria-hidden="true">${burstSVG(kind, iconText)}</div>
        </div>
        <div class="msgText">
          <div class="headline">${headline || ""}</div>
          <div class="sub">${sub || ""}</div>
        </div>
      </div>
    `;
  }

  function closeSuggest() {
    suggestBox.style.display = 'none';
    suggestBox.innerHTML = '';
    activeSuggestionIndex = -1;
    currentSuggestions = [];
    lastRenderedQuery = "";
  }

  function openSuggest() { suggestBox.style.display = 'block'; }

  function renderSuggestions(query) {
    const q = norm(query);
    if (!q) { closeSuggest(); return; }
    if (q === lastRenderedQuery) return;

    const matches = countries
      .filter(c => norm(c.name.common).startsWith(q))
      .slice(0, 25);

    if (!matches.length) { closeSuggest(); return; }

    suggestBox.innerHTML = '';
    currentSuggestions = matches.map(c => ({
      name: c.name.common,
      continent: continentLabel(c.region, c.subregion)
    }));

    activeSuggestionIndex = 0;

    currentSuggestions.forEach((it, idx) => {
      const row = document.createElement('div');
      row.className = 'sgItem' + (idx === 0 ? ' active' : '');
      row.innerHTML = `<span>${it.name}</span><span class="sgMeta">${it.continent}</span>`;
      row.addEventListener('mousedown', (e) => {
        e.preventDefault();
        guessInput.value = it.name;
        closeSuggest();
        guessInput.focus();
      });
      suggestBox.appendChild(row);
    });

    lastRenderedQuery = q;
    openSuggest();
  }

  function moveActive(delta) {
    if (suggestBox.style.display !== 'block') return;
    if (!currentSuggestions.length) return;

    activeSuggestionIndex += delta;
    if (activeSuggestionIndex < 0) activeSuggestionIndex = currentSuggestions.length - 1;
    if (activeSuggestionIndex >= currentSuggestions.length) activeSuggestionIndex = 0;

    [...suggestBox.querySelectorAll('.sgItem')].forEach((el, idx) => {
      el.classList.toggle('active', idx === activeSuggestionIndex);
    });

    const activeEl = suggestBox.querySelectorAll('.sgItem')[activeSuggestionIndex];
    if (activeEl) activeEl.scrollIntoView({ block: 'nearest' });
  }

  function applySuggestionSelectionToInput() {
    if (suggestBox.style.display !== 'block') return false;
    if (!currentSuggestions.length) return false;

    const idx = Math.max(0, activeSuggestionIndex);
    const pickItem = currentSuggestions[idx] || currentSuggestions[0];
    if (pickItem?.name) {
      guessInput.value = pickItem.name;
      closeSuggest();
      return true;
    }
    return false;
  }

  function currentAcceptedNames(c) {
    const accepted = new Set();
    accepted.add(norm(c.name?.common));
    accepted.add(norm(c.name?.official));
    (c.altSpellings || []).forEach(s => accepted.add(norm(s)));

    const common = norm(c.name?.common);
    if (common === 'united states') accepted.add('usa');
    if (common === 'united kingdom') accepted.add('uk');
    if (common === 'russia') accepted.add('russian federation');
    if (common === 'south korea') accepted.add('korea');
    if (common === 'czechia') accepted.add('czech republic');
    return accepted;
  }

  function fmtNumber(n){
    if (!Number.isFinite(n)) return 'â€”';
    return n.toLocaleString('en-US');
  }

  function neighborsList(c){
    const borders = Array.isArray(c.borders) ? c.borders : [];
    const names = borders
      .map(code => cca3ToCountry.get(code)?.name?.common)
      .filter(Boolean);

    if (!names.length) return `Â· <b>Neighbors</b>: <b>none</b> (island / solo mode) ğŸï¸`;

    const sample = names.slice(0, 6);
    const extra = names.length > sample.length ? ` (+${names.length - sample.length} more)` : '';
    return `Â· <b>Neighbors</b>: ${sample.join(', ')}${extra} ğŸ¤`;
  }

  const FOOD_HINT = {
    "Iran": `date palms & saffron rice with meat (Chelo Kabab) ğŸšğŸ¥©`,
    "Peru": `ceviche + lomo saltado ğŸŸğŸ¥”`,
    "Japan": `sushi + ramen ğŸ£ğŸœ`,
    "Italy": `pasta + espresso ğŸâ˜•`,
    "Mexico": `tacos al pastor + mole ğŸŒ®ğŸ«`,
    "India": `biryani + masala chai ğŸ›â˜•`,
    "Thailand": `pad thai + green curry ğŸŒ¶ï¸ğŸœ`,
    "Turkey": `kebabs + baklava ğŸ¥™ğŸ¯`,
    "Morocco": `tagine + mint tea ğŸ«–ğŸ²`,
    "Ethiopia": `injera + wats ğŸ²`,
    "France": `croissant + cheese ğŸ¥ğŸ§€`,
    "United States": `burgers + BBQ ğŸ”ğŸ”¥`,
    "Australia": `flat white + meat pie + â€œbarbieâ€ culture â˜•ğŸ¥§`
  };

  const FAMOUS_PERSON = {
    "Australia": "Chris Hemsworth (actor) ğŸ¬",
    "New Zealand": "Taika Waititi (filmmaker) ğŸ¬",
    "United States": "BeyoncÃ© (musician) ğŸ¤",
    "Canada": "Ryan Reynolds (actor) ğŸ¬",
    "United Kingdom": "David Bowie (musician) ğŸ¸",
    "France": "Marie Curie (scientist) âš—ï¸",
    "Germany": "Albert Einstein (scientist) ğŸ§ ",
    "Japan": "Hayao Miyazaki (filmmaker) ğŸ¬",
    "India": "Mahatma Gandhi (leader) ğŸ•Šï¸",
    "Brazil": "PelÃ© (athlete) âš½",
    "Mexico": "Frida Kahlo (artist) ğŸ¨",
    "Peru": "Mario Vargas Llosa (writer) ğŸ“š"
  };

  const SYMBOLISM_ONE_LINER = {
    "Peru": "Red honors sacrifice in the independence struggle; white stands for peace/purity.",
    "Iran": "Green/white/red are tied to growth/peace/courage; emblem/pattern reference Islamic identity.",
    "Japan": "Red sun disc represents the sunâ€”Japan as the â€˜land of the rising sun.â€™",
    "France": "Tricolor tied to the Revolution; often read as liberty/equality/fraternity."
  };

  function rjSlugForCountry(name){
    const slug = name.toLowerCase()
      .replace(/â€™/g,'')
      .replace(/'/g,'')
      .replace(/&/g,'and')
      .replace(/[^a-z0-9 ]/g,'')
      .trim()
      .replace(/\s+/g, '-');
    return `https://www.rjtravelagency.com/flag-of-${slug}/`;
  }

  function symbolismBlock(c){
    const name = c.name.common;
    const one = SYMBOLISM_ONE_LINER[name];
    const url = rjSlugForCountry(name);
    return one
      ? `â„¹ï¸ <b>Flag meaning</b>: ${one}`
      : `â„¹ï¸ <a href="${url}" target="_blank" rel="noopener"><b>Learn more about this flag</b></a>`;
  }

  function hint1Food(c){
    const name = c.name.common;
    if (FOOD_HINT[name]) return FOOD_HINT[name];

    const cont = continentLabel(c.region, c.subregion);
    const fallback = {
      "Europe": "cheese + bread + something fermented ğŸ§€ğŸ¥–",
      "Asia": "noodles/rice + a signature spice combo ğŸœğŸš",
      "Africa": "stews + grains + slow-cooked magic ğŸ²",
      "North America": "BBQ or tacosâ€¦ possibly both ğŸ”¥ğŸŒ®",
      "Central America": "beans + rice + coffee fuel â˜•ğŸ›",
      "Caribbean": "jerk seasoning + tropical fruit ğŸ¥­ğŸŒ¶ï¸",
      "South America": "grilled meats + corn things ğŸ¥©ğŸŒ½",
      "Oceania": "BBQ + beach picnic energy ğŸ–ï¸ğŸ¥©",
      "Other": "mystery snacks from a parallel universe ğŸ¥ªğŸ§"
    };
    return fallback[cont] || fallback["Other"];
  }

  function hintForTry(c, tryUsed){
    if (tryUsed === 1) {
      const cont = continentLabel(c.region, c.subregion);
      return [
        `Â· <b>Continent</b>: ${cont} ğŸŒ`,
        `Â· <b>Food</b>: ${hint1Food(c)}`
      ].join('<br/>');
    }
    if (tryUsed === 2) {
      const pop = fmtNumber(Math.round(c.population || 0));
      const celeb = FAMOUS_PERSON[c.name.common] || `A person too powerful for this hint engine ğŸ•¶ï¸`;
      return [
        `Â· <b>Famous Name</b>: ${celeb}`,
        `Â· <b>Population</b>: ${pop} ğŸ‘¥`,
        neighborsList(c)
      ].join('<br/>');
    }

    const name = c.name.common;
    const n = norm(name).replace(/ /g,'');
    const ends = n.slice(-3);
    const patterns = [
      { suffix: 'land', words: ['sand','hand','band','grand'] },
      { suffix: 'ia', words: ['see-ya','pizzeria','utopia','chia'] },
      { suffix: 'stan', words: ['plan','fan','can','pan'] },
      { suffix: 'ana', words: ['banana','cabana','bandana','nirvana'] },
      { suffix: 'ine', words: ['wine','fine','line','shine'] },
    ];
    for (const p of patterns){
      if (n.endsWith(p.suffix)) return `Â· <b>Rhymes-ish</b>: ${p.words.join(', ')} ğŸ¶`;
    }
    return `Â· <b>Sound clue</b>: ends like â€œ${ends}â€â€¦ try yelling â€œ${ends}!â€ dramatically ğŸ­`;
  }

  function renderFlag() {
    closeSuggest();
    const c = currentCountry();
    if (!c) return;

    const url = c.flags?.png || c.flags?.svg || '';
    flagImg.src = url;
    flagImg.alt = `Flag of ${c.name?.common || 'Unknown'}`;

    triesLeft = TRIES_PER_FLAG;
    guessInput.value = '';
    guessInput.focus();
    updateHUD();

    renderMsg('neutral','', `Type a country name.`);
  }

  function pointsForTry(tryNumberUsed) {
    if (tryNumberUsed === 1) return 3;
    if (tryNumberUsed === 2) return 2;
    if (tryNumberUsed === 3) return 1;
    return 0;
  }

  /* =============================================================================================
     SECTION: CONFETTI (more volume; slower; longer when round ends)
     ============================================================================================= */
  function confettiBurst(ms=3000, count=520, slow=true){
    const dpr = window.devicePixelRatio || 1;
    const w = Math.floor(window.innerWidth * dpr);
    const h = Math.floor(window.innerHeight * dpr);

    confettiCanvas.width = w;
    confettiCanvas.height = h;

    const ctx = confettiCanvas.getContext('2d');
    const pieces = [];
    const colors = ['#ff6b6b','#ffd93d','#6bcBef','#6bff95','#b36bff','#ff9f43'];

    for (let i=0;i<count;i++){
      const baseVy = slow ? (Math.random()*0.9+0.65) : (Math.random()*1.2+1.1);
      pieces.push({
        x: Math.random()*w,
        y: -40 - Math.random()*h*0.35,
        vx: (Math.random()*2-1) * dpr * 1.2,
        vy: baseVy * dpr * 1.45,
        r: (Math.random()*4+3) * dpr,
        rot: Math.random()*Math.PI,
        vr: (Math.random()*0.16-0.08),
        c: colors[Math.floor(Math.random()*colors.length)],
        life: Math.random()*0.6 + 0.4
      });
    }

    confettiLayer.style.display = 'block';

    const start = performance.now();
    function tick(t){
      const p = Math.min(1, (t-start)/ms);
      ctx.clearRect(0,0,w,h);

      const fade = Math.max(0, 1 - p);

      for (const s of pieces){
        s.x += s.vx;
        s.y += s.vy;
        s.rot += s.vr;
        s.vy += 0.012 * dpr; // slower gravity
        s.vx *= 0.996;
        s.vy *= 0.999;

        const alpha = Math.max(0, fade * s.life);

        ctx.save();
        ctx.translate(s.x, s.y);
        ctx.rotate(s.rot);
        ctx.globalAlpha = alpha;
        ctx.fillStyle = s.c;
        ctx.fillRect(-s.r, -s.r, s.r*2.2, s.r*1.2);
        ctx.restore();
      }

      if (p < 1) requestAnimationFrame(tick);
      else confettiLayer.style.display = 'none';
    }
    requestAnimationFrame(tick);
  }

  /* =============================================================================================
     SECTION: ROUND TRANSITION (re-add dramatic â€œzoom from horizonâ€ overlay + confetti)
     ============================================================================================= */
  function roundTransition(nextRoundNumber){
    roundOverlayText.textContent = `ROUND ${nextRoundNumber}!`;

    // start from "vanishing point" (lower) tiny -> huge -> fade
    roundOverlay.style.display = 'grid';
    roundOverlayText.style.opacity = '0';
    roundOverlayText.style.transform = 'translateY(140px) scale(0.02)';
    roundOverlayText.style.filter = 'blur(0.8px)';

    // big confetti rain for ~3s
    confettiBurst(3000, 760, true);

    requestAnimationFrame(() => {
      roundOverlayText.style.transition = 'transform 850ms cubic-bezier(.12,.75,.18,1), opacity 260ms ease, filter 850ms ease';
      roundOverlayText.style.opacity = '1';
      roundOverlayText.style.transform = 'translateY(0px) scale(1.06)';
      roundOverlayText.style.filter = 'blur(0px)';

      setTimeout(() => {
        roundOverlayText.style.transition = 'opacity 320ms ease';
        roundOverlayText.style.opacity = '0';
        setTimeout(() => {
          roundOverlay.style.display = 'none';
          renderFlag();
        }, 340);
      }, 980);
    });
  }

  function advanceFlag() {
    flagIdx++;
    if (flagIdx >= FLAGS_PER_ROUND) {
      roundIdx++;
      flagIdx = 0;

      if (roundIdx >= rounds.length) {
        renderMsg('success',`ğŸ Game complete! Final score: <b>${score}</b> ğŸ‰`, `Hit RESTART to play again.`);
        submitBtn.disabled = true;
        skipBtn.disabled = true;
        guessInput.disabled = true;
        updateHUD();
        return;
      }

      updateHUD();

      // More confetti + round overlay after each round (10 flags)
      roundTransition(roundIdx + 1);
      return;
    }

    renderFlag();
  }

  function consumeTryWithHint() {
    const c = currentCountry();
    if (!c) return;
    if (triesLeft <= 0) return;

    const tryUsed = TRIES_PER_FLAG - triesLeft + 1;
    const hint = hintForTry(c, tryUsed);

    triesLeft--;
    updateHUD();

    if (triesLeft <= 0) {
      renderMsg(
        'fail',
        `Out of tries! Answer: <b>${c.name.common}</b>.`,
        `${symbolismBlock(c)}<br/><br/>Next flag in <b>${Math.round(PAUSE_WRONG_MS/1000)}s</b>â€¦`
      );
      setTimeout(() => advanceFlag(), PAUSE_WRONG_MS);
      return;
    }

    renderMsg(
      'hint',
      `Hint Used (costs a try!)`,
      `${hint}<br/><br/>You have <b>${triesLeft}</b> tries left.`
    );
  }

  function submitGuess() {
    const c = currentCountry();
    if (!c) return;

    applySuggestionSelectionToInput();

    const guess = guessInput.value;
    const guessN = norm(guess);
    const accepted = currentAcceptedNames(c);
    const tryUsed = TRIES_PER_FLAG - triesLeft + 1;

    if (guessN && accepted.has(guessN)) {
      const pts = pointsForTry(tryUsed);
      score += pts;
      updateHUD();

      const emoji = pick(["ğŸ‰","ğŸ¥³","âœ¨"]);
      renderMsg(
        'success',
        `Correct! That was <b>${c.name.common}</b>. ${emoji}`,
        `You earned <b>${pts}</b> point${pts === 1 ? '' : 's'}.<br/><br/>Next flag in <b>${Math.round(PAUSE_CORRECT_MS/1000)}s</b>â€¦`
      );
      setTimeout(() => advanceFlag(), PAUSE_CORRECT_MS);
      return;
    }

    triesLeft--;
    updateHUD();

    if (triesLeft <= 0) {
      renderMsg(
        'fail',
        `Nope. Answer: <b>${c.name.common}</b>.`,
        `${symbolismBlock(c)}<br/><br/>Next flag in <b>${Math.round(PAUSE_WRONG_MS/1000)}s</b>â€¦`
      );
      setTimeout(() => advanceFlag(), PAUSE_WRONG_MS);
      return;
    }

    renderMsg(
      'fail',
      `Not quite.`,
      `Try again. You have <b>${triesLeft}</b> tries left. (Hit <b>.</b> for a hint â€” it costs a try.)`
    );

    guessInput.select();
    guessInput.focus();
  }

  function skipFlag() {
    const c = currentCountry();
    if (!c) return;

    renderMsg(
      'neutral',
      `Skipped. Answer: <b>${c.name.common}</b>.`,
      `${symbolismBlock(c)}<br/><br/>Next flag in <b>${Math.round(PAUSE_WRONG_MS/1000)}s</b>â€¦`
    );
    setTimeout(() => advanceFlag(), PAUSE_WRONG_MS);
  }

  function restart() {
    roundIdx = 0;
    flagIdx = 0;
    triesLeft = TRIES_PER_FLAG;
    score = 0;
    submitBtn.disabled = false;
    skipBtn.disabled = false;
    guessInput.disabled = false;
    renderFlag();
  }

  const WELL_KNOWN = new Set([
    'United States','Canada','Mexico','Brazil','Argentina','Chile','Colombia','Peru',
    'United Kingdom','Ireland','France','Spain','Portugal','Italy','Germany','Netherlands','Belgium','Switzerland','Austria','Sweden','Norway','Denmark','Finland','Iceland',
    'Russia','Ukraine','Poland','Czechia','Greece','Turkey',
    'China','Japan','South Korea','India','Pakistan','Bangladesh','Sri Lanka','Thailand','Vietnam','Indonesia','Philippines','Malaysia','Singapore',
    'Australia','New Zealand',
    'Egypt','South Africa','Nigeria','Kenya','Ethiopia','Ghana','Morocco','Tunisia',
    'Saudi Arabia','United Arab Emirates','Qatar','Iran','Iraq','Israel','Jordan','Lebanon','Syria'
  ]);

  function familiarityScore(c) {
    const pop = Math.max(0, c.population || 0);
    const popScore = Math.log10(pop + 1);
    const knownBoost = WELL_KNOWN.has(c.name.common) ? 6 : 0;
    return popScore + knownBoost;
  }

  function buildRoundsSmart(countries) {
    const scored = countries.map(c => ({ c, ease: familiarityScore(c) }));
    scored.sort((a,b) => b.ease - a.ease);

    const totalPossibleRounds = Math.floor(scored.length / FLAGS_PER_ROUND);
    const roundsCount = Math.max(6, Math.min(12, totalPossibleRounds));
    const bandSize = Math.floor(scored.length / roundsCount);

    const out = [];
    for (let r = 0; r < roundsCount; r++) {
      const start = r * bandSize;
      const end = (r === roundsCount - 1) ? scored.length : (r + 1) * bandSize;
      const band = scored.slice(start, end).map(x => x.c);
      shuffle(band);
      out.push(band.slice(0, FLAGS_PER_ROUND));
    }
    return out;
  }

  /* =============================================================================================
     SECTION: TOP+BOTTOM FLAG BANDS (ONE band, mirrored)
     - 10% flags are colored but washed out 50% (i.e. 0.5 opacity wash)
     - Non-colored flags are GREY OUTLINES with recognizable detail (edge-based line-art)
     - Occlusion: later items draw on top
     - Footer is a vertical mirror of header (NO independent generation)
     ============================================================================================= */

  let bandCache = null;

  function seededRand(seed){
    // xorshift32
    let x = seed >>> 0;
    return () => {
      x ^= x << 13; x >>>= 0;
      x ^= x >> 17; x >>>= 0;
      x ^= x << 5;  x >>>= 0;
      return (x >>> 0) / 4294967296;
    };
  }

  function buildBandCache(){
    const bandH = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--bandH'), 10) || 210;
    const w = Math.max(1400, window.innerWidth);
    const h = Math.max(180, bandH);

    // deterministic per (w,h) so header/footer match exactly per resize
    const rand = seededRand((w * 73856093) ^ (h * 19349663));

    const flagW = 54;
    const flagH = 34;

    // spacing: scattered (avoid columns)
    const padX = 18;
    const padY = 12;
    const cellW = flagW * 0.92;
    const cellH = flagH * 0.95;

    const cols = Math.max(10, Math.floor((w - padX*2) / cellW));
    const rows = Math.max(4, Math.floor((h - padY*2) / cellH));

    const pts = [];
    for (let r=0;r<rows;r++){
      for (let c=0;c<cols;c++){
        const xBase = padX + c * cellW;
        const yBase = padY + r * cellH;

        // larger jitter to break vertical alignment
        const jx = (rand()*2-1) * (cellW * 0.75);
        const jy = (rand()*2-1) * (cellH * 0.55);

        pts.push({ x: xBase + jx, y: yBase + jy });
      }
    }

    // keep all points (this is a band, not a mountain)
    pts.sort((a,b)=> a.y - b.y);

    const coloredCount = Math.max(1, Math.floor(pts.length * 0.10));
    const coloredIdx = new Set();
    while (coloredIdx.size < coloredCount) coloredIdx.add(Math.floor(rand() * pts.length));

    // choose a country for each tile (random, deterministic)
    const items = pts.map((p, i) => {
      const cc = countries.length ? countries[Math.floor(rand()*countries.length)] : null;
      const url = cc?.flags?.png || cc?.flags?.svg || '';
      const rot = (rand()*10 - 5);
      const scale = 1.0 * (0.92 + rand() * 0.22);
      return { i, x:p.x, y:p.y, rot, scale, colored: coloredIdx.has(i), url };
    });

    // draw order by y for occlusion
    items.sort((a,b)=> a.y - b.y);

    bandCache = { w, h, flagW, flagH, items };
  }

  function renderBand(svgEl, invertY){
    if (!bandCache) buildBandCache();

    const { w, h, flagW, flagH, items } = bandCache;

    svgEl.setAttribute('viewBox', `0 0 ${w} ${h}`);
    svgEl.innerHTML = '';

    const NS = 'http://www.w3.org/2000/svg';

    const defs = document.createElementNS(NS,'defs');

    // outline filter: edge detect -> grey; preserve detail
    const f = document.createElementNS(NS,'filter');
    f.setAttribute('id','lineArt');
    f.setAttribute('x','-20%'); f.setAttribute('y','-20%');
    f.setAttribute('width','140%'); f.setAttribute('height','140%');

    const f1 = document.createElementNS(NS,'feColorMatrix');
    f1.setAttribute('type','matrix');
    // grayscale
    f1.setAttribute('values', `
      0.2126 0.7152 0.0722 0 0
      0.2126 0.7152 0.0722 0 0
      0.2126 0.7152 0.0722 0 0
      0      0      0      1 0
    `);
    f1.setAttribute('result','g');

    const f2 = document.createElementNS(NS,'feConvolveMatrix');
    f2.setAttribute('in','g');
    f2.setAttribute('order','3');
    f2.setAttribute('kernelMatrix', `
      -1 -1 -1
      -1  8 -1
      -1 -1 -1
    `);
    f2.setAttribute('result','edge');

    const f3 = document.createElementNS(NS,'feComponentTransfer');
    f3.setAttribute('in','edge');
    f3.setAttribute('result','edge2');

    const fnR = document.createElementNS(NS,'feFuncR');
    const fnG = document.createElementNS(NS,'feFuncG');
    const fnB = document.createElementNS(NS,'feFuncB');
    // boost visibility: clamp to darker greys
    fnR.setAttribute('type','gamma'); fnR.setAttribute('amplitude','1'); fnR.setAttribute('exponent','0.75'); fnR.setAttribute('offset','0');
    fnG.setAttribute('type','gamma'); fnG.setAttribute('amplitude','1'); fnG.setAttribute('exponent','0.75'); fnG.setAttribute('offset','0');
    fnB.setAttribute('type','gamma'); fnB.setAttribute('amplitude','1'); fnB.setAttribute('exponent','0.75'); fnB.setAttribute('offset','0');
    f3.appendChild(fnR); f3.appendChild(fnG); f3.appendChild(fnB);

    const f4 = document.createElementNS(NS,'feColorMatrix');
    f4.setAttribute('in','edge2');
    f4.setAttribute('type','matrix');
    // tint edges to grey and slightly fade
    f4.setAttribute('values', `
      0 0 0 0 0.32
      0 0 0 0 0.36
      0 0 0 0 0.44
      0 0 0 0.85 0
    `);
    f4.setAttribute('result','tinted');

    const f5 = document.createElementNS(NS,'feMerge');
    const m1 = document.createElementNS(NS,'feMergeNode'); m1.setAttribute('in','tinted');
    f5.appendChild(m1);

    f.appendChild(f1);
    f.appendChild(f2);
    f.appendChild(f3);
    f.appendChild(f4);
    f.appendChild(f5);

    defs.appendChild(f);
    svgEl.appendChild(defs);

    // group for optional inversion (mirror)
    const gRoot = document.createElementNS(NS,'g');
    if (invertY) {
      gRoot.setAttribute('transform', `translate(0 ${h}) scale(1 -1)`);
    }

    // draw items top-to-bottom so later overlap occludes earlier
    for (const it of items) {
      const g = document.createElementNS(NS,'g');
      g.setAttribute('transform', `translate(${it.x},${it.y}) rotate(${it.rot}) scale(${it.scale})`);

      // base rectangle (paper card, subtle)
      const base = document.createElementNS(NS,'rect');
      base.setAttribute('x','0'); base.setAttribute('y','0');
      base.setAttribute('width', String(flagW));
      base.setAttribute('height', String(flagH));
      base.setAttribute('rx','0'); base.setAttribute('ry','0');
      base.setAttribute('fill','rgba(255,255,255,0.78)');
      base.setAttribute('stroke','rgba(37,48,65,0.22)');
      base.setAttribute('stroke-width','1.0');
      g.appendChild(base);

      if (it.url) {
        const img = document.createElementNS(NS,'image');
        img.setAttribute('href', it.url);
        img.setAttribute('x','0'); img.setAttribute('y','0');
        img.setAttribute('width', String(flagW));
        img.setAttribute('height', String(flagH));
        img.setAttribute('preserveAspectRatio','none'); // keep rectangle, no italics

        if (it.colored) {
          // colored but washed out 50%
          img.setAttribute('opacity','0.50');
        } else {
          // line-art outline (recognizable details) + slight fade
          img.setAttribute('filter','url(#lineArt)');
          img.setAttribute('opacity','0.92');
        }
        g.appendChild(img);
      }

      gRoot.appendChild(g);
    }

    svgEl.appendChild(gRoot);
  }

  function buildBands(){
    bandCache = null;
    buildBandCache();
    renderBand(headerSvg, false);
    renderBand(footerSvg, true);
  }

  // Footer positioning: starts after message module; svg itself is fixed-height and pinned bottom.
  function positionFooter(){
    const msgRect = belowMsg.getBoundingClientRect();
    const pad = 10;
    const topPx = Math.min(
      Math.max(msgRect.bottom + pad, window.innerHeight * 0.60),
      window.innerHeight - 140
    );
    footerEl.style.top = `${Math.round(topPx)}px`;
    footerEl.style.height = `${Math.max(0, Math.round(window.innerHeight - topPx))}px`;
  }

  // Events
  submitBtn.addEventListener('click', submitGuess);
  skipBtn.addEventListener('click', skipFlag);
  restartBtnTop.addEventListener('click', () => { restart(); buildBands(); positionFooter(); });

  guessInput.addEventListener('input', (e) => renderSuggestions(e.target.value));
  guessInput.addEventListener('focus', () => { if (guessInput.value) renderSuggestions(guessInput.value); });

  document.addEventListener('mousedown', (e) => {
    const inWrap = e.target === guessInput || suggestBox.contains(e.target);
    if (!inWrap) closeSuggest();
  });

  guessInput.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowDown') { e.preventDefault(); moveActive(+1); return; }
    if (e.key === 'ArrowUp') { e.preventDefault(); moveActive(-1); return; }
    if (e.key === 'Escape') { closeSuggest(); return; }

    if (e.key === 'Enter') {
      e.preventDefault();
      if (suggestBox.style.display === 'block' && currentSuggestions.length) {
        applySuggestionSelectionToInput();
      }
      submitGuess();
      return;
    }
  });

  document.addEventListener('keydown', (e) => {
    if (e.key !== '.') return;
    if (e.metaKey || e.ctrlKey || e.altKey) return;
    const t = e.target;
    const isTextField = t && (t.tagName === 'INPUT' || t.tagName === 'TEXTAREA') && !t.readOnly && !t.disabled;
    if (isTextField) e.preventDefault();
    consumeTryWithHint();
    guessInput.focus();
  });

  // Boot
  async function loadCountries() {
    const res = await fetch(
      'https://restcountries.com/v3.1/all?fields=name,flags,altSpellings,population,region,subregion,cca3,borders'
    );
    if (!res.ok) throw new Error(`Failed to fetch countries: ${res.status}`);

    const data = await res.json();

    countries = data
      .filter(c => c?.name?.common && (c?.flags?.png || c?.flags?.svg))
      .map(c => ({
        name: c.name,
        altSpellings: c.altSpellings || [],
        flags: c.flags,
        population: c.population || 0,
        region: c.region || '',
        subregion: c.subregion || '',
        cca3: c.cca3 || '',
        borders: Array.isArray(c.borders) ? c.borders : []
      }));

    cca3ToCountry = new Map();
    for (const c of countries) {
      if (c.cca3) cca3ToCountry.set(c.cca3, c);
    }

    rounds = buildRoundsSmart(countries);

    buildBands();
    positionFooter();
    restart();
  }

  loadCountries().catch(err => {
    console.error(err);
    renderMsg('fail',`Couldnâ€™t load country data.`, `${String(err.message || err)}`);
  });

  window.addEventListener('resize', () => { buildBands(); positionFooter(); });
})();
</script>
</body>
</html>
