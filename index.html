  /* =============================================================================================
     SECTION 9: HEADER/FOOTER FLAGS (tune grey-outline: 1px light grey, no rectangle border)
     - Colored flags unchanged (perfect).
     - Grey flags: thinner, lighter, and NO surrounding rectangle.
  ============================================================================================= */
  let FLAGFIELD_ITEMS = null;

  function buildFlagFields() {
    if (!countries.length) return;

    const topEl = flagFieldTopSvg;
    const botEl = flagFieldBottomSvg;

    const w = Math.max(1400, window.innerWidth);
    const h = Math.max(240, Math.round(document.querySelector('.flagField--top').getBoundingClientRect().height));

    topEl.setAttribute('viewBox', `0 0 ${w} ${h}`);
    botEl.setAttribute('viewBox', `0 0 ${w} ${h}`);

    if (!FLAGFIELD_ITEMS || FLAGFIELD_ITEMS.w !== w || FLAGFIELD_ITEMS.h !== h) {
      const count = Math.floor((w * h) / 6800);
      const items = [];

      const coloredCount = Math.max(1, Math.floor(count * 0.10));
      const coloredIdx = new Set();
      while (coloredIdx.size < coloredCount) coloredIdx.add(Math.floor(Math.random() * count));

      for (let i = 0; i < count; i++) {
        const c = countries[Math.floor(Math.random() * countries.length)];
        const url = (c.flags && (c.flags.svg || c.flags.png)) || '';
        if (!url) continue;

        const x = Math.random() * (w - 60);
        const y = Math.random() * (h - 40);

        const rot = (Math.random() * 10 - 5);

        items.push({
          url,
          x, y,
          rot,
          colored: coloredIdx.has(i)
        });
      }

      items.sort((a,b) => a.y - b.y);

      FLAGFIELD_ITEMS = { w, h, items };
    }

    topEl.innerHTML = flagFieldSVGMarkup(FLAGFIELD_ITEMS.items, FLAGFIELD_ITEMS.w, FLAGFIELD_ITEMS.h, false);
    botEl.innerHTML = flagFieldSVGMarkup(FLAGFIELD_ITEMS.items, FLAGFIELD_ITEMS.w, FLAGFIELD_ITEMS.h, true);
  }

  function flagFieldSVGMarkup(items, w, h, mirrorY) {
    const mirrorOpen = mirrorY ? `<g transform="translate(0 ${h}) scale(1 -1)">` : `<g>`;
    const mirrorClose = `</g>`;

    const defs = `
      <defs>
        <!-- Thin "line-art" filter (aim ~1px): binary masks -> outline (dilate - erode) -->
        <filter id="lineArt" x="-30%" y="-30%" width="160%" height="160%" color-interpolation-filters="sRGB">
          <feColorMatrix type="saturate" values="0" result="g"/>

          <!-- contrast boost (kept modest to avoid chunky edges) -->
          <feComponentTransfer in="g" result="c">
            <feFuncR type="gamma" amplitude="1.15" exponent="0.60" offset="-0.02"/>
            <feFuncG type="gamma" amplitude="1.15" exponent="0.60" offset="-0.02"/>
            <feFuncB type="gamma" amplitude="1.15" exponent="0.60" offset="-0.02"/>
          </feComponentTransfer>

          <!-- luminance into alpha -->
          <feColorMatrix in="c" type="matrix" result="lumA"
            values="
              0 0 0 0 0
              0 0 0 0 0
              0 0 0 0 0
              0.333 0.333 0.333 0 0"/>

          <!-- mask for DARK features: alpha = 1 - lum -->
          <feComponentTransfer in="lumA" result="darkA">
            <feFuncA type="table" tableValues="1 0"/>
          </feComponentTransfer>

          <!-- threshold dark mask -->
          <feComponentTransfer in="darkA" result="darkT">
            <feFuncA type="linear" slope="3.0" intercept="-1.20"/>
          </feComponentTransfer>

          <!-- outline dark: *thin* dilate - erode -->
          <feMorphology in="darkT" operator="dilate" radius="0.65" result="darkD"/>
          <feMorphology in="darkT" operator="erode"  radius="0.65" result="darkE"/>
          <feComposite in="darkD" in2="darkE" operator="arithmetic" k1="0" k2="1" k3="-1" k4="0" result="darkO"/>

          <!-- mask for LIGHT features -->
          <feComponentTransfer in="lumA" result="lightT">
            <feFuncA type="linear" slope="3.0" intercept="-1.65"/>
          </feComponentTransfer>

          <!-- outline light: *thin* dilate - erode -->
          <feMorphology in="lightT" operator="dilate" radius="0.65" result="lightD"/>
          <feMorphology in="lightT" operator="erode"  radius="0.65" result="lightE"/>
          <feComposite in="lightD" in2="lightE" operator="arithmetic" k1="0" k2="1" k3="-1" k4="0" result="lightO"/>

          <!-- union outlines -->
          <feComposite in="darkO" in2="lightO" operator="arithmetic" k1="0" k2="1" k3="1" k4="0" result="u"/>

          <!-- soften just a hair so it reads like 1px -->
          <feGaussianBlur in="u" stdDeviation="0.18" result="s"/>

          <!-- tint to LIGHT GREY with alpha from s -->
          <feColorMatrix in="s" type="matrix" result="ink"
            values="
              0 0 0 0 0.55
              0 0 0 0 0.58
              0 0 0 0 0.62
              0 0 0 0.55 0"/>

          <feComposite in="ink" in2="ink" operator="over"/>
        </filter>

        <filter id="flagShadow" x="-40%" y="-40%" width="200%" height="200%">
          <feDropShadow dx="0" dy="1.5" stdDeviation="1.6" flood-color="rgba(0,0,0,0.12)"/>
        </filter>
      </defs>
    `;

    let out = `${defs}${mirrorOpen}`;

    for (const it of items) {
      const fw = 40;
      const fh = 25;

      if (it.colored) {
        out += `
          <g transform="translate(${it.x.toFixed(1)},${it.y.toFixed(1)}) rotate(${it.rot.toFixed(2)})" filter="url(#flagShadow)">
            <image href="${it.url}" width="${fw}" height="${fh}" opacity="0.50" preserveAspectRatio="none"></image>
          </g>
        `;
      } else {
        out += `
          <g transform="translate(${it.x.toFixed(1)},${it.y.toFixed(1)}) rotate(${it.rot.toFixed(2)})" filter="url(#flagShadow)">
            <image href="${it.url}" width="${fw}" height="${fh}" opacity="0.90" filter="url(#lineArt)" preserveAspectRatio="none"></image>
          </g>
        `;
      }
    }

    out += `${mirrorClose}`;
    return out;
  }
