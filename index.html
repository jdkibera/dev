/**
 * =================================================================================================
 * SFR3 FUND â€” SHARED UTILITIES (zz_Helpers.gs)
 * =================================================================================================
 *
 * PURPOSE
 *   Central library for shared utility functions used across the SFR3 Apps Script project.
 *   Naming this file "zz_" ensures it loads last, making these helpers available globally.
 *
 * QUICK START (WHAT TO CALL)
 *   â€¢ Slack:                 postToSlack(channel, text, footerText?, footerLinks?, imageUrl?)
 *   â€¢ TAB hyperlinking:      addTabHyperlinksCAQandSAQ(), addTabHyperlinksCAQ(), addTabHyperlinksSAQ()
 *   â€¢ Grant ID hashing:      computeGlobalGrantHash(...)   // SINGLE SOURCE OF TRUTH
 *   â€¢ Data helpers:          _ns_*                          // generally side-effect free
 *   â€¢ Vesting/ledger utils:  getQuarterData(), findFundingQuarter(), computeGrantHash()
 *
 * INDEX & USAGE MAP
 *
 * 1) SLACK NOTIFICATIONS
 *    - postToSlack()
 *    Used by: `NewInvestorLetterFolders.gs`
 *
 * 2) TAB HYPERLINKING
 *    - addTabHyperlinksCAQandSAQ(), addTabHyperlinksCAQ(), addTabHyperlinksSAQ(), addTabHyperlinksForSheets()
 *    Used by: `SUBSAllQuartersStatic`, `buildCARRYAllQuarters`
 *
 * 3) CRITICAL BUSINESS LOGIC (GRANT HASHING)
 *    - computeGlobalGrantHash()
 *    Used by: `buildVestingSchedule`, `issueGrants`, `VestingScheduleCleanup`
 *    NOTE: This is the Single Source of Truth for Grant IDs.
 *
 * 4) SHEET & DATA HELPERS (Namespace: _ns_)
 *    - _ns_getLastRowWithData()
 *      Used by: `issueGrants`, `VestingScheduleCleanup`
 *    - _ns_safeDeleteRow()
 *      Used by: `VestingScheduleCleanup`
 *    - _ns_normKey(), _ns_parseNumber(), _ns_loadStatements(), _ns_getCashAccount()
 *      Used by: `buildSubsData`, `updateSUBSAllQuarters`
 *
 * 5) VESTING & LEDGER HELPERS
 *    - getQuarterData(), findFundingQuarter(), computeGrantHash()
 *
 * CRITICAL BUSINESS RULES
 *   1) HASH IMMUTABILITY: computeGlobalGrantHash() MUST NOT CHANGE. Altering it will invalidate
 *      every existing Grant ID in the system and can cause orphan deletion.
 *   2) READ-ONLY HELPERS: _ns_ functions (except delete) are designed to be side-effect free.
 *
 * VERSION HISTORY
 *   v1.0 - Initial Aggregation.
 *   v1.4 - Added Tab Hyperlinkers (v1.4) & Slack (v1.2).
 *   v2.0 - Documentation Upgrade (Standardized Header & Data Sources).
 * =================================================================================================
 */




// =================================================================================================
//   SECTION 1: CONFIGURATION
// =================================================================================================

const SLACK_BOT_TOKEN = PropertiesService.getScriptProperties().getProperty('SLACK_BOT_TOKEN');




// =================================================================================================
//   SECTION 2: SLACK UTILITIES
// =================================================================================================

/**
 * Posts a message to a Slack channel using a bot token.
 * Supports plain-text messages, messages with footer attachments, and image embeds.
 *
 * @param {string} channel - Slack channel ID or name.
 * @param {string} text - The main message to post.
 * @param {string} [footerText=null] - Optional text to display in the attachment footer.
 * @param {string} [footerLinks=null] - Optional footer links to display.
 * @param {string} [imageUrl=null] - Optional URL of the image to embed.
 */
function postToSlack(channel, text, footerText = null, footerLinks = null, imageUrl = null) {
  let payload;

  if (footerText || footerLinks || imageUrl) {
    // Rich message with footer and/or image
    let attachment = {
      text: footerText || "",
      footer: footerLinks || "",
      mrkdwn_in: ["text", "footer"]
    };

    // Add image if provided
    if (imageUrl) {
      attachment.image_url = imageUrl;
    }

    payload = {
      channel: channel,
      text: text,
      attachments: [attachment],
      link_names: true
    };
  } else {
    // Plain-text message (backwards compatible)
    payload = {
      channel: channel,
      text: text,
      link_names: true
    };
  }

  const options = {
    method: 'POST',
    contentType: 'application/json',
    headers: {
      Authorization: `Bearer ${SLACK_BOT_TOKEN}`,
    },
    payload: JSON.stringify(payload),
    muteHttpExceptions: true
  };

  try {
    const response = UrlFetchApp.fetch('https://slack.com/api/chat.postMessage', options);
    const result = JSON.parse(response.getContentText());

    if (!result.ok) {
      Logger.log(`Slack post error: ${JSON.stringify(result)}`);
      throw new Error(`Failed to post to Slack: ${result.error}`);
    }

    Logger.log(`âœ… Message posted successfully to channel ${channel}.`);
  } catch (e) {
    Logger.log(`âŒ Error posting to Slack: ${e.message}`);
  }
}




// =================================================================================================
//   SECTION 3: TAB HYPERLINKER UTILITIES
// =================================================================================================

function addTabHyperlinksCAQandSAQ() {
  addTabHyperlinksForSheets(['CARRY All Quarters', 'SUBS All Quarters']);
}

function addTabHyperlinksCAQ() {
  addTabHyperlinksForSheets(['CARRY All Quarters']);
}

function addTabHyperlinksSAQ() {
  addTabHyperlinksForSheets(['SUBS All Quarters']);
}

function addTabHyperlinksForSheets(sheetNames) {
  const ss = SpreadsheetApp.getActive();
  const results = sheetNames.map(name => _addTabHyperlinksOne(ss, name));
  Logger.log('âœ… addTabHyperlinksForSheets done: ' + JSON.stringify(results));
}

function _addTabHyperlinksOne(ss, sheetName) {
  const sh = ss.getSheetByName(sheetName);
  if (!sh) return { sheetName, updated: 0, note: 'sheet not found' };

  // NEW: remove any active basic filter so we always operate on all rows.
  const filter = sh.getFilter();
  if (filter) {
    filter.remove();
    Logger.log(`ðŸ”Ž addTabHyperlinks: removed basic filter on "${sheetName}" before updating TAB links.`);
  }

  const lastRow = sh.getLastRow();
  const lastCol = sh.getLastColumn();
  if (lastRow < 2) return { sheetName, updated: 0, note: 'no data' };

  const header = String(sh.getRange(1, lastCol).getValue()).trim();
  if (header.toUpperCase() !== 'TAB') {
    return { sheetName, updated: 0, note: `last column header is "${header}", not "TAB"` };
  }

  const allSheetsByName = new Map(ss.getSheets().map(s => [s.getName(), s]));
  const vals = sh.getRange(2, lastCol, lastRow - 1, 1).getValues();

  let changed = 0;
  const out = vals.map(([tabRaw]) => {
    const tab = String(tabRaw || '').trim();
    if (!tab) return [null];

    const target = allSheetsByName.get(tab);
    if (!target) return [tab]; // leave plain text if target sheet doesn't exist

    const gid = target.getSheetId();
    const url = `#gid=${gid}`; // internal link only
    
    // Strip trailing " Subs" from label (case-insensitive, with/without spaces)
    let label = tab.replace(/\s*subs\s*$/i, '').trim();

    // Escape quotes for formula safety
    const labelEsc = label.replace(/"/g, '""');

    changed++;
    return [`=HYPERLINK("${url}","${labelEsc}")`];
  });

  // Bulk write over the full TAB column (all rows, filtered or not).
  sh.getRange(2, lastCol, out.length, 1).setFormulas(out);

  Logger.log(`âœ… addTabHyperlinks: ${sheetName} Â· processed ${out.length}, hyperlinked ${changed}`);
  return { sheetName, updated: changed };
}




// =================================================================================================
//   SECTION 4: BUSINESS LOGIC (GRANT HASHING)
// =================================================================================================

/**
 * The single source of truth for Grant ID Hashing.
 * Ensures Vesting, Orphan Cleanup, and Emailing all use identical IDs.
 */
function computeGlobalGrantHash(entity, funding, units, startDate, periodMo, cliffMo, freqTxt) {
  var tz = Session.getScriptTimeZone() || 'America/Los_Angeles';
  
  // Standardize the date string to prevent timezone-based hash drift
  var dateStr = (startDate instanceof Date) 
    ? Utilities.formatDate(startDate, tz, "yyyy-MM-dd") 
    : String(startDate || "");

  // Create the unique key
  var key = [
    String(entity || '').trim(),
    String(funding || '').trim(),
    String(units || 0),
    dateStr,
    String(periodMo || 0),
    String(cliffMo || 0),
    String(freqTxt || '').trim().toUpperCase()
  ].join('|');

  // Generate 3-character alphanumeric hash
  var h = 0;
  for (var i = 0; i < key.length; i++) {
    h = (h * 31 + key.charCodeAt(i)) & 0x7fffffff;
  }
  
  var alpha = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  var out = "";
  var n = h;
  for (var j = 0; j < 3; j++) {
    out = alpha.charAt(n % 36) + out;
    n = Math.floor(n / 36);
  }
  return out || "000";
}




// =================================================================================================
//   SECTION 5: DATA HELPERS (NAMESPACE _ns_)
// =================================================================================================

// ---------------------------------------------------------------------------
// Robust Last Row Detection: Scans Col A bottom-up to find the true floor.
// Use this instead of .getLastRow() to avoid phantom blank rows.
// ---------------------------------------------------------------------------
function _ns_getLastRowWithData(sheet) {
  if (!sheet) return 0;
  var lastRow = sheet.getLastRow();
  if (lastRow === 0) return 0;
  var values = sheet.getRange(1, 1, lastRow, 1).getValues();
  for (var r = lastRow - 1; r >= 0; r--) {
    if (String(values[r][0]).trim() !== '') return r + 1;
  }
  return 0;
}

// ---------------------------------------------------------------------------
// Safe Row Deletion: Deletes or Clears depending on non-frozen row limits.
// ---------------------------------------------------------------------------
function _ns_safeDeleteRow(sheet, rIdx) {
  if (!sheet || rIdx <= 0) return;
  var max = sheet.getLastRow();
  if (rIdx > max) return; // Out of bounds safety
  
  try {
    sheet.deleteRow(rIdx);
  } catch (e) {
    if (String(e).indexOf('non-frozen rows') > -1) {
      sheet.getRange(rIdx, 1, 1, sheet.getLastColumn() || 1).clearContent();
    } else {
      throw e;
    }
  }
}

// ---------------------------------------------------------------------------
// Normalize a header or key: uppercase, trim, collapse spaces.
// Example: " Prev  Units " -> "PREV UNITS"
// ---------------------------------------------------------------------------
function _ns_normKey(str) {
  return String(str || '')
    .trim()
    .replace(/\s+/g, ' ')
    .toUpperCase();
}

// ---------------------------------------------------------------------------
// Robust number parser: handles "$1,234", "(123.45)", blanks, NaN.
// Returns 0 for anything non-numeric.
// ---------------------------------------------------------------------------
function _ns_parseNumber(v) {
  if (typeof v === 'number') return v;

  const s = String(v || '').trim();
  if (!s) return 0;

  const neg = /^\(.*\)$/.test(s);
  const cleaned = s
    .replace(/[\$,]/g, '')
    .replace(/^\((.*)\)$/, '$1');

  const n = Number(cleaned);
  return isNaN(n) ? 0 : (neg ? -n : n);
}

// ---------------------------------------------------------------------------
// In-memory cache for statements, keyed by sheet name.
// Cleared automatically each run because Apps Script has no persistent RAM.
// ---------------------------------------------------------------------------
var _ns_statementsCache = {};

// ---------------------------------------------------------------------------
// Load values from a statement-like sheet (YYYY Statements or YYYY Balances).
// Returns a 2D array (including header).
// Caches results within the same execution.
// ---------------------------------------------------------------------------
function _ns_loadStatements(sheet) {
  if (!sheet) throw new Error('_ns_loadStatements: sheet not provided');

  const name = sheet.getName();
  if (_ns_statementsCache[name]) return _ns_statementsCache[name];

  const lr = sheet.getLastRow();
  const lc = sheet.getLastColumn();

  const vals = lr ? sheet.getRange(1, 1, lr, lc).getValues() : [[]];
  _ns_statementsCache[name] = vals;
  return vals;
}

// ---------------------------------------------------------------------------
// Return a cash-account field if present in an object mapping.
// If multiple aliases exist, return the first match.
//
// Example usage:
//   const acct = _ns_getCashAccount({ "CASH ACCOUNT": "A123", "..." });
// ---------------------------------------------------------------------------
function _ns_getCashAccount(map) {
  if (!map || typeof map !== 'object') return '';

  const keys = Object.keys(map).map(_ns_normKey);

  const candidates = [
    'CASH ACCOUNT',
    'ACCOUNT',
    'CASHACCT',
    'CASH'
  ];

  for (let c of candidates) {
    const idx = keys.indexOf(c);
    if (idx !== -1) return map[Object.keys(map)[idx]] || '';
  }

  return '';
}




// =================================================================================================
//   SECTION 6: VESTING & LEDGER HELPERS
// =================================================================================================

/**
 * 1. CACHE QUARTER DATA
 * Reads the QUARTERS tab once so we don't hit the spreadsheet 500 times in a loop.
 */
function getQuarterData() {
  var ss = SpreadsheetApp.getActive();
  var sh = ss.getSheetByName('QUARTERS');
  return sh ? sh.getDataRange().getValues() : [];
}

/**
 * 2. FIND FUNDING QUARTER
 * Determines the correct "Funding Quarter" (e.g. "2023 Q4") for a given Start Date
 * using the cached quarters data.
 */
function findFundingQuarter(quarterData, startDate) {
  if (!startDate || !quarterData.length) return null;
  
  // Convert Date -> "YYYY Qn"
  var d = new Date(startDate);
  var q = Math.floor(d.getMonth() / 3) + 1;
  var startLabel = d.getFullYear() + ' Q' + q;

  // Find the PIDX (Pointer Index) for the start quarter
  var pidx = null;
  for (var i = 1; i < quarterData.length; i++) {
    if (String(quarterData[i][2]).trim() === startLabel) {
      pidx = quarterData[i][4];
      break;
    }
  }
  if (!pidx) return null;

  // Find the nearest valid Funding Quarter (forward looking)
  var bestLabel = null;
  var minDiff = 999999;
  
  for (var i = 1; i < quarterData.length; i++) {
    var rowQIdx = Number(quarterData[i][1]);
    if (rowQIdx >= pidx && (rowQIdx - pidx) < minDiff) {
      minDiff = rowQIdx - pidx;
      bestLabel = quarterData[i][0];
    }
  }
  return bestLabel;
}

/**
 * 3. COMPUTE HASH
 * The standard ID generator. Any change here changes ALL ledger IDs.
 */
function computeGrantHash(entityName, fundingLabel, grantUnits, startDate, periodMo, cliffMo, freqTxt) {
  var tz = Session.getScriptTimeZone() || 'America/Los_Angeles';
  var dateStr = (startDate instanceof Date) ? Utilities.formatDate(startDate, tz, 'yyyy-MM-dd') : String(startDate || '');
  
  var key = [
    String(entityName || '').trim(),
    String(fundingLabel || '').trim(),
    String(grantUnits || 0),
    dateStr,
    String(periodMo || 0),
    String(cliffMo || 0),
    String(freqTxt || '').trim().toUpperCase()
  ].join('|');

  var hash = 0;
  for (var i = 0; i < key.length; i++) {
    hash = (hash * 31 + key.charCodeAt(i)) & 0x7fffffff;
  }
  
  var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  var out = '';
  var n = hash;
  for (var j = 0; j < 3; j++) {
    out = alphabet.charAt(n % 36) + out;
    n = Math.floor(n / 36);
  }
  return out || '000';
}
