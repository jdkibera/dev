<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Kibera's Flag Gauntlet</title>

  <!-- Keep original brand font (DO NOT REGRESS) -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Calligraffitti&display=swap" rel="stylesheet">

  <style>
    /* =============================================================================================
       SECTION A: THEME / LAYOUT CONSTANTS
       (Only changed where explicitly requested in the prompt.)
    ============================================================================================= */
    :root{
      --bg: #E1E8F3;
      --ink: #253041;
      --card: rgba(11,16,32,0.92);
      --cardBorder: rgba(0,0,0,0.18);
      --pillBg: rgba(255,255,255,0.10);

      --flagStageH: 340px;

      /* Messaging area: fixed layout so nothing jumps */
      --msgH: 320px;
      --iconColW: 210px;

      --brandBlueGrey: rgba(80, 110, 140, 0.42);
    }

    html, body { height: 100%; }
    body{
      margin: 0;
      background: var(--bg);
      color: var(--ink);
      min-height: 100vh;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      display:flex;
      flex-direction: column;
      overflow-x: hidden;
    }

    .main{
      flex: 1;
      display: grid;
      place-items: center;
      padding: 70px 14px 10px;
      position: relative;
      z-index: 2;
    }

    .wrap{
      width: min(980px, 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 14px;
      position: relative;
    }

    /* Keep original brand font (Calligraffitti) ‚Äî DO NOT REGRESS */
    .brandAngle{
      position: absolute;
      left: -132px;
      top: 118px;
      transform: rotate(-45deg);
      transform-origin: left top;
      font-family: "Calligraffitti", "Snell Roundhand", "Apple Chancery", "Segoe Script", cursive;
      font-size: 46px;
      font-weight: 400;
      color: var(--brandBlueGrey);
      user-select: none;
      pointer-events: none;
      z-index: 10;
      line-height: 0.92;
      text-align: center;
      width: 250px;
    }

    .topbar{
      width: min(900px, 100%);
      display:flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
      justify-content: center;
      margin-bottom: 2px;
      position: relative;
      z-index: 5;
    }

    .pill{
      padding: 10px 14px;
      border-radius: 999px;
      background: var(--pillBg);
      border: 1px solid rgba(0,0,0,0.08);
      font-size: 18px;
      color: #0b1020;
      display:flex;
      align-items:center;
      gap: 10px;
      backdrop-filter: blur(6px);
      white-space: nowrap;
    }
    .pill b{ font-size: 20px; }

    .restartBtnTop{
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid rgba(0,0,0,0.12);
      background: rgba(0,0,0,0.06);
      color: #0b1020;
      cursor: pointer;
      font-size: 13px;
      white-space: nowrap;
      letter-spacing: 0.8px;
      font-weight: 900;
    }
    .restartBtnTop:hover{ background: rgba(0,0,0,0.10); }

    .card{
      width: min(900px, 100%);
      background: var(--card);
      border: 1px solid var(--cardBorder);
      border-radius: 18px;
      padding: 18px 18px 16px;
      color: #e9eefc;
      box-shadow: 0 18px 45px rgba(0,0,0,0.25);
      position: relative;
      z-index: 3;
    }

    .questionTitle{
      text-align: center;
      margin: 6px 0 10px;
      font-size: 34px;
      letter-spacing: 0.3px;
      font-weight: 200;
      opacity: 0.95;
      font-family: "Helvetica Neue", Helvetica, Arial, system-ui, sans-serif;
    }

    .flagStage{
      height: var(--flagStageH);
      width: 100%;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 6px 0 12px;
      box-sizing: border-box;
    }

    /* =============================================================================================
       SECTION B: MAIN FLAG DISPLAY (leave unchanged unless explicitly requested)
       Requested: flag size 500x300
    ============================================================================================= */
    .flag{
      width: 500px;
      height: 300px;
      max-width: 92%;
      max-height: calc(var(--flagStageH) - 18px);
      object-fit: contain;
      border-radius: 14px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.04);
    }

    .controls{
      display:flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      margin-top: 0px;
    }
    .controlRow{
      width: min(520px, 92%);
      display:flex;
      align-items: stretch;
      gap: 10px;
    }

    .inputWrap{ flex: 1; position: relative; }
    input[type="text"]{
      width: 100%;
      padding: 16px 14px;
      font-size: 18px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.35);
      color: #e9eefc;
      outline: none;
      box-sizing: border-box;
    }
    input[type="text"]::placeholder{ color: rgba(233,238,252,0.65); }

    .btnCol{
      display:flex;
      gap: 10px;
      align-items: stretch;
    }

    button{
      padding: 12px 14px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(90,140,255,0.22);
      color: #e9eefc;
      cursor: pointer;
      min-width: 96px;
      font-size: 13px;
      font-weight: 900;
      letter-spacing: 0.9px;
    }
    button:hover{ background: rgba(90,140,255,0.33); }
    button:disabled{ opacity: 0.55; cursor: not-allowed; }

    /* Hint CTA: only under input */
    .hintHotkeyLine{
      width: min(520px, 92%);
      text-align: left;
      font-size: 15px;
      color: rgba(233,238,252,0.78);
      margin-top: -2px;
      font-family: "Helvetica Neue", Helvetica, Arial, system-ui, sans-serif;
      font-weight: 300;
    }
    .hintHotkeyLine b{ color: rgba(233,238,252,0.90); font-weight: 650; }

    .suggestBox{
      position: absolute;
      left: 0; right: 0;
      top: calc(100% + 8px);
      background: rgba(14, 20, 40, 0.98);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 14px;
      box-shadow: 0 18px 45px rgba(0,0,0,0.45);
      overflow: hidden;
      z-index: 50;
      display: none;
      max-height: 320px;
      overflow-y: auto;
    }
    .sgItem{
      padding: 10px 12px;
      cursor: pointer;
      color: #e9eefc;
      border-top: 1px solid rgba(255,255,255,0.06);
      display:flex;
      justify-content: space-between;
      gap: 12px;
      align-items: center;
    }
    .sgItem:hover, .sgItem.active{ background: rgba(90,140,255,0.22); }
    .sgMeta{ font-size: 12px; opacity: 0.70; white-space: nowrap; }

    /* =============================================================================================
       SECTION C: MESSAGE MODULE
    ============================================================================================= */
    .belowMsg{
      width: min(900px, 100%);
      height: var(--msgH);
      display: grid;
      place-items: center;
      overflow: hidden;
      z-index: 2;
      position: relative;
    }

    .msgGrid{
      width: min(900px, 100%);
      display: grid;
      grid-template-columns: var(--iconColW) minmax(0, 1fr);
      align-items: start;
      gap: 18px;
      padding: 0 6px;
      box-sizing: border-box;
    }

    .iconCol{
      display:flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      padding-top: 2px;
    }

    .iconSq{
      width: 190px;
      height: 140px;
      border-radius: 0;
      border: none;
      background: transparent;
      overflow: visible;
      display: grid;
      place-items: center;
      box-shadow: none;
    }
    .iconSq svg{
      width: 100%;
      height: 100%;
      display:block;
      overflow: visible;
    }

    .iconLabel{ display:none; }

    /* Messaging typography */
    .msgText{
      text-align: left;
      line-height: 1.25;
      align-self: start;
      padding-top: 6px;
      font-family: "Helvetica Neue", Helvetica, Arial, system-ui, sans-serif;
      font-weight: 300;
    }
    .msgText .headline{
      font-size: 26px;
      margin: 0 0 10px;
      min-height: 30px;
      color: rgba(37,48,65,0.92);
      font-weight: 320;
    }
    .msgText .sub{
      font-size: 20px;
      opacity: 0.92;
      margin: 0;
      min-height: 96px;
      color: rgba(37,48,65,0.86);
      font-weight: 300;
    }
    .msgText b{ font-weight: 520; }
    .msgText a{
      color: rgba(30,80,170,0.95);
      text-decoration: underline;
      font-weight: 520;
    }

    .bottomArea{
      width: 100%;
      position: relative;
      z-index: 1;
    }

    .copyright{
      position: fixed;
      left: 0;
      width: 100%;
      bottom: 50px;
      text-align: center;
      color: rgba(37,48,65,0.75);
      font-size: 13px;
      letter-spacing: 0.3px;
      z-index: 3;
      pointer-events: none;
      font-family: "Helvetica Neue", Helvetica, Arial, system-ui, sans-serif;
      font-weight: 300;
    }

    /* =============================================================================================
       SECTION D: HEADER + FOOTER FLAG FIELDS
    ============================================================================================= */

    .flagField--bottom{ display:none; }
    
    .flagField{
      position: fixed;
      left: 0;
      width: 100vw;
      pointer-events: none;
      z-index: 0;
      overflow: hidden;
    }

    .flagField--top{
      top: 0;
      height: 240px;
    }
    .flagField--bottom{
      bottom: 0;
      height: 240px;
    }

    .flagFieldSvg{
      position:absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      opacity: 1;
    }

    /* Top: solid at top -> transparent towards bottom */
    .flagField--top .flagFieldSvg{
      mask-image: linear-gradient(
        to bottom,
        rgba(0,0,0,1.00) 0%,
        rgba(0,0,0,1.00) 35%,
        rgba(0,0,0,0.65) 62%,
        rgba(0,0,0,0.00) 100%
      );
    }
    /* Bottom: transparent at top -> solid at bottom */
    .flagField--bottom .flagFieldSvg{
      mask-image: linear-gradient(
        to bottom,
        rgba(0,0,0,0.00) 0%,
        rgba(0,0,0,0.25) 22%,
        rgba(0,0,0,0.75) 60%,
        rgba(0,0,0,1.00) 100%
      );
    }

    .confettiLayer{
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 9999;
      display: none;
    }

    .roundOverlay{
      position: fixed;
      inset: 0;
      display: none;
      pointer-events: none;
      z-index: 10000;
      place-items: center;
      text-align: center;
    }

    .roundOverlay .big{
      font-family: "Impact", "Haettenschweiler", "Arial Black", system-ui, sans-serif;
      font-weight: 900;
      font-size: min(160px, 17vw);
      line-height: 0.95;
      color: #FFD400;
      -webkit-text-stroke: 10px rgba(0,0,0,0.92);
      paint-order: stroke fill;
      text-shadow:
        0 10px 0 rgba(0,0,0,0.12),
        0 22px 55px rgba(0,0,0,0.25);
      transform: translateZ(0);
      padding: 14px 22px;
      border-radius: 18px;
      background: rgba(255,255,255,0.0);
    }

    .roundBurst{
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      opacity: 0;
      transform: scale(0.12);
      filter: drop-shadow(0 26px 40px rgba(0,0,0,0.18));
    }

    .roundBurst.show{
      animation: burstZoom 1.05s ease-out forwards;
    }

    @keyframes burstZoom{
      0%   { opacity: 0; transform: translateY(180px) scale(0.12); }
      55%  { opacity: 1; transform: translateY(0px) scale(1.02); }
      100% { opacity: 0; transform: translateY(-10px) scale(1.10); }
    }

    @media (max-width: 900px){
      .brandAngle{ left: -122px; top: 130px; font-size: 40px; width: 230px; }
      .questionTitle{ font-size: 30px; }
      :root{ --iconColW: 190px; --msgH: 300px; }
      .msgText .headline{ font-size: 24px; }
      .msgText .sub{ font-size: 19px; }
      .flagField--top, .flagField--bottom{ height: 220px; }
    }
    @media (max-width: 760px){
      :root{ --iconColW: 178px; --msgH: 290px; }
      .pill{ font-size: 16px; }
      .pill b{ font-size: 18px; }
      .questionTitle{ font-size: 26px; }
      .brandAngle{ font-size: 34px; left: -110px; top: 140px; width: 210px; }
      .flagField--top, .flagField--bottom{ height: 200px; }
    }
  </style>
</head>

<body>
  <div class="flagField flagField--top" aria-hidden="true">
    <svg id="flagFieldTopSvg" class="flagFieldSvg" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="none"></svg>
  </div>

  <div class="confettiLayer" id="confettiLayer">
    <canvas id="confettiCanvas" style="width:100%;height:100%"></canvas>
  </div>

  <div class="roundOverlay" id="roundOverlay">
    <div class="roundBurst" id="roundBurst"></div>
    <div class="big" id="roundOverlayText">ROUND 2</div>
  </div>

  <div class="main">
    <div class="wrap">
      <div class="brandAngle">Kibera's<br/>Flag Gauntlet</div>

      <div class="topbar">
        <div class="pill">Round: <b id="roundNum">1</b> / <span id="roundTotal">?</span></div>
        <div class="pill">Flag: <b id="flagIndex">1</b> / <b id="flagsPerRound">10</b></div>
        <div class="pill">Tries left: <b id="triesLeft">3</b></div>
        <div class="pill">
          Score: <b id="score">0</b>
          <button class="restartBtnTop" id="restartBtnTop" title="Restart from Round 1">RESTART</button>
        </div>
      </div>

      <div class="card" id="card">
        <div class="questionTitle">What Country's Flag Is This?</div>

        <div class="flagStage">
          <img id="flagImg" class="flag" alt="Country flag" />
        </div>

        <div class="controls">
          <div class="controlRow">
            <div class="inputWrap">
              <input id="guessInput" type="text" placeholder="Type a country name‚Ä¶" autocomplete="off" />
              <div id="suggestBox" class="suggestBox" role="listbox" aria-label="Country suggestions"></div>
            </div>

            <div class="btnCol">
              <button id="submitBtn">SUBMIT</button>
              <button id="skipBtn" title="Give up on this flag (0 points)">SKIP</button>
            </div>
          </div>

          <div class="hintHotkeyLine">
            Hit the period <b>&ldquo;.&rdquo;</b> key for a hint! Each hint costs a try
          </div>
        </div>
      </div>

      <div class="belowMsg" id="belowMsg"></div>
    </div>
  </div>

  <div class="bottomArea">
    <div class="copyright">¬© 2026 Kibera &amp; Co.</div>
  </div>

  <div class="flagField flagField--bottom" aria-hidden="true">
    <svg id="flagFieldBottomSvg" class="flagFieldSvg" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="none"></svg>
  </div>

<script>
(() => {
  /* =============================================================================================
     SECTION 1: GAME CONSTANTS (unchanged unless explicitly requested)
  ============================================================================================= */
  const FLAGS_PER_ROUND = 10;
  const TRIES_PER_FLAG = 3;

  const PAUSE_CORRECT_MS = 2000;
  const PAUSE_WRONG_MS   = 7000;

  /* =============================================================================================
     SECTION 2: UI HOOKS (unchanged)
  ============================================================================================= */
  const roundNumEl = document.getElementById('roundNum');
  const roundTotalEl = document.getElementById('roundTotal');
  const flagIndexEl = document.getElementById('flagIndex');
  const flagsPerRoundEl = document.getElementById('flagsPerRound');
  const triesLeftEl = document.getElementById('triesLeft');
  const scoreEl = document.getElementById('score');

  const flagImg = document.getElementById('flagImg');
  const guessInput = document.getElementById('guessInput');
  const submitBtn = document.getElementById('submitBtn');
  const skipBtn = document.getElementById('skipBtn');
  const restartBtnTop = document.getElementById('restartBtnTop');

  const suggestBox = document.getElementById('suggestBox');
  const belowMsg = document.getElementById('belowMsg');

  const confettiLayer = document.getElementById('confettiLayer');
  const confettiCanvas = document.getElementById('confettiCanvas');
  const roundOverlay = document.getElementById('roundOverlay');
  const roundOverlayText = document.getElementById('roundOverlayText');
  const roundBurst = document.getElementById('roundBurst');

  const flagFieldTopSvg = document.getElementById('flagFieldTopSvg');
  const flagFieldBottomSvg = document.getElementById('flagFieldBottomSvg');

  /* =============================================================================================
     SECTION 3: GAME STATE (unchanged)
  ============================================================================================= */
  let countries = [];
  let rounds = [];
  let roundIdx = 0;
  let flagIdx = 0;
  let triesLeft = TRIES_PER_FLAG;
  let score = 0;

  let activeSuggestionIndex = -1;
  let currentSuggestions = [];
  let lastRenderedQuery = "";

  let cca3ToCountry = new Map();

  function pick(arr){ return arr[Math.floor(Math.random() * arr.length)]; }

  function norm(s) {
    return String(s || '')
      .trim()
      .toLowerCase()
      .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
      .replace(/[^a-z0-9 ]/g, '')
      .replace(/\s+/g, ' ');
  }

  function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  function updateHUD() {
    roundNumEl.textContent = String(roundIdx + 1);
    roundTotalEl.textContent = String(rounds.length || '?');
    flagIndexEl.textContent = String(flagIdx + 1);
    flagsPerRoundEl.textContent = String(FLAGS_PER_ROUND);
    triesLeftEl.textContent = String(triesLeft);
    scoreEl.textContent = String(score);
  }

  function currentCountry() {
    return rounds?.[roundIdx]?.[flagIdx] || null;
  }

  function continentLabel(region, subregion) {
    const r = String(region || '').trim();
    const s = String(subregion || '').trim();
    if (!r) return 'Other';
    if (r === 'Americas') {
      if (s.includes('South')) return 'South America';
      if (s.includes('North')) return 'North America';
      if (s.includes('Caribbean')) return 'Caribbean';
      if (s.includes('Central')) return 'Central America';
      return 'Americas';
    }
    return r;
  }

  /* =============================================================================================
     SECTION 4: COMIC BURST ICON (minor tweaks only)
     - Remove grey dots around burst
     - Center text on the diagonal (rotate around center)
     - IMPORTANT: keep renderMsg() (this is why messaging disappeared)
  ============================================================================================= */
  function burstSVG(kind, text){
    const styles = {
      default: { txt:'#4AA3FF', burst1:'#FF3D2E', burst2:'#FFB02E' },
      success: { txt:'#4AA3FF', burst1:'#FF3D2E', burst2:'#FFB02E' },
      fail:    { txt:'#FFD400', burst1:'#FF3D2E', burst2:'#FFB02E' },
      go:      { txt:'#36E06B', burst1:'#0E7A2F', burst2:'#B7F74A' },
      hint:    { txt:'#76C8FF', burst1:'#3D66FF', burst2:'#B07BFF' },
      round:   { txt:'#FFD400', burst1:'#FF3D2E', burst2:'#FFB02E' },
    };
    const s = styles[kind] || styles.default;

    const burstStroke = 3.2;
    const textStrokeThin = 4.2;

    // ViewBox center (for stable diagonal centering)
    const CX = 130;
    const CY = 95;

    return `
    <svg viewBox="0 0 260 190" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
      <defs>
        <radialGradient id="bgGrad_${kind}" cx="40%" cy="35%" r="75%">
          <stop offset="0%"  stop-color="${s.burst2}" stop-opacity="1"/>
          <stop offset="65%" stop-color="${s.burst1}" stop-opacity="1"/>
          <stop offset="100%" stop-color="${s.burst1}" stop-opacity="1"/>
        </radialGradient>

        <filter id="softShadow_${kind}" x="-20%" y="-20%" width="140%" height="140%">
          <feDropShadow dx="0" dy="7" stdDeviation="5" flood-color="rgba(0,0,0,0.25)"/>
        </filter>
      </defs>

      <g filter="url(#softShadow_${kind})">
        <path d="M132 10
                 L150 34 L178 18 L178 46 L210 38 L196 64 L236 70 L204 84
                 L232 104 L196 106 L210 136 L178 124 L178 154 L154 140
                 L140 176 L124 150 L96 174 L96 146 L66 156 L78 128
                 L40 132 L58 108 L26 92 L58 88 L38 62 L76 64
                 L64 36 L96 46 L96 18 L122 34 Z"
              fill="url(#bgGrad_${kind})"
              stroke="rgba(0,0,0,0.92)"
              stroke-width="${burstStroke}"
              stroke-linejoin="round"/>
        <path d="M132 26
                 L144 42 L166 32 L166 52 L190 48 L180 66 L210 72 L186 82
                 L206 96 L180 98 L190 118 L166 108 L166 128 L146 118
                 L138 146 L126 124 L106 140 L106 120 L84 126 L92 108
                 L64 110 L76 94 L54 84 L76 80 L60 64 L90 66
                 L82 46 L106 54 L106 34 L124 42 Z"
              fill="rgba(255,255,255,0.14)"/>
      </g>

      <!-- Center text on diagonal -->
      <g transform="rotate(-45 ${CX} ${CY})">
        <text x="${CX}" y="${CY}"
              text-anchor="middle"
              dominant-baseline="middle"
              font-family="Bazinga, 'Bangers', 'Impact', system-ui, sans-serif"
              font-weight="900"
              font-size="46"
              fill="${s.txt}"
              stroke="rgba(0,0,0,0.92)"
              stroke-width="${textStrokeThin}"
              paint-order="stroke fill"
              letter-spacing="1.2">${String(text || '').toUpperCase()}</text>
      </g>
    </svg>`;
  }

  function renderMsg(kind, iconText, headline, sub){
    belowMsg.innerHTML = `
      <div class="msgGrid">
        <div class="iconCol">
          <div class="iconSq" aria-hidden="true">
            ${burstSVG(kind, iconText || "LET'S GO!")}
          </div>
        </div>
        <div class="msgText">
          <div class="headline">${headline || ""}</div>
          <div class="sub">${sub || ""}</div>
        </div>
      </div>
    `;
  }

  /* =============================================================================================
     SECTION 5: SUGGEST UI (unchanged)
  ============================================================================================= */
  function closeSuggest() {
    suggestBox.style.display = 'none';
    suggestBox.innerHTML = '';
    activeSuggestionIndex = -1;
    currentSuggestions = [];
    lastRenderedQuery = "";
  }
  function openSuggest() { suggestBox.style.display = 'block'; }

  function renderSuggestions(query) {
    const q = norm(query);
    if (!q) { closeSuggest(); return; }
    if (q === lastRenderedQuery) return;

    const matches = countries
      .filter(c => norm(c.name.common).startsWith(q))
      .slice(0, 25);

    if (!matches.length) { closeSuggest(); return; }

    suggestBox.innerHTML = '';
    currentSuggestions = matches.map(c => ({
      name: c.name.common,
      continent: continentLabel(c.region, c.subregion)
    }));

    activeSuggestionIndex = 0;

    currentSuggestions.forEach((it, idx) => {
      const row = document.createElement('div');
      row.className = 'sgItem' + (idx === 0 ? ' active' : '');
      row.innerHTML = `<span>${it.name}</span><span class="sgMeta">${it.continent}</span>`;
      row.addEventListener('mousedown', (e) => {
        e.preventDefault();
        guessInput.value = it.name;
        closeSuggest();
        guessInput.focus();
      });
      suggestBox.appendChild(row);
    });

    lastRenderedQuery = q;
    openSuggest();
  }

  function moveActive(delta) {
    if (suggestBox.style.display !== 'block') return;
    if (!currentSuggestions.length) return;

    activeSuggestionIndex += delta;
    if (activeSuggestionIndex < 0) activeSuggestionIndex = currentSuggestions.length - 1;
    if (activeSuggestionIndex >= currentSuggestions.length) activeSuggestionIndex = 0;

    [...suggestBox.querySelectorAll('.sgItem')].forEach((el, idx) => {
      el.classList.toggle('active', idx === activeSuggestionIndex);
    });

    const activeEl = suggestBox.querySelectorAll('.sgItem')[activeSuggestionIndex];
    if (activeEl) activeEl.scrollIntoView({ block: 'nearest' });
  }

  function applySuggestionSelectionToInput() {
    if (suggestBox.style.display !== 'block') return false;
    if (!currentSuggestions.length) return false;

    const idx = Math.max(0, activeSuggestionIndex);
    const pickItem = currentSuggestions[idx] || currentSuggestions[0];
    if (pickItem?.name) {
      guessInput.value = pickItem.name;
      closeSuggest();
      return true;
    }
    return false;
  }

  /* =============================================================================================
     SECTION 6: ANSWER MATCHING / HINTS (UPDATED: one-hint mode)
  ============================================================================================= */
  function currentAcceptedNames(c) {
    const accepted = new Set();
    accepted.add(norm(c.name?.common));
    accepted.add(norm(c.name?.official));
    (c.altSpellings || []).forEach(s => accepted.add(norm(s)));

    const common = norm(c.name?.common);
    if (common === 'united states') accepted.add('usa');
    if (common === 'united kingdom') accepted.add('uk');
    if (common === 'russia') accepted.add('russian federation');
    if (common === 'south korea') accepted.add('korea');
    if (common === 'czechia') accepted.add('czech republic');
    return accepted;
  }

  function fmtNumber(n){
    if (!Number.isFinite(n)) return '‚Äî';
    return n.toLocaleString('en-US');
  }

  function neighborsList(c){
    const borders = Array.isArray(c.borders) ? c.borders : [];
    const names = borders
      .map(code => cca3ToCountry.get(code)?.name?.common)
      .filter(Boolean);

    if (!names.length) return `¬∑ <b>Neighbors</b>: <b>none</b> (island / solo mode) üèùÔ∏è`;

    const sample = names.slice(0, 6);
    const extra = names.length > sample.length ? ` (+${names.length - sample.length} more)` : '';
    return `¬∑ <b>Neighbors</b>: ${sample.join(', ')}${extra} ü§ù`;
  }

  const FOOD_HINT = {
    "Iran": `date palms & saffron rice with meat (Chelo Kabab) üçöü•©`,
    "Peru": `ceviche + lomo saltado üêüü•î`,
    "Japan": `sushi + ramen üç£üçú`,
    "Italy": `pasta + espresso üçù‚òï`,
    "Mexico": `tacos al pastor + mole üåÆüç´`,
    "India": `biryani + masala chai üçõ‚òï`,
    "Thailand": `pad thai + green curry üå∂Ô∏èüçú`,
    "Turkey": `kebabs + baklava ü•ôüçØ`,
    "Morocco": `tagine + mint tea ü´ñüç≤`,
    "Ethiopia": `injera + wats üç≤`,
    "France": `croissant + cheese ü•êüßÄ`,
    "United States": `burgers + BBQ üçîüî•`,
    "Australia": `flat white + meat pie + ‚Äúbarbie‚Äù culture ‚òïü•ß`
  };

  const FAMOUS_PERSON = {
    "Australia": "Chris Hemsworth (actor) üé¨",
    "New Zealand": "Taika Waititi (filmmaker) üé¨",
    "United States": "Beyonc√© (musician) üé§",
    "Canada": "Ryan Reynolds (actor) üé¨",
    "United Kingdom": "David Bowie (musician) üé∏",
    "France": "Marie Curie (scientist) ‚öóÔ∏è",
    "Germany": "Albert Einstein (scientist) üß†",
    "Japan": "Hayao Miyazaki (filmmaker) üé¨",
    "India": "Mahatma Gandhi (leader) üïäÔ∏è",
    "Brazil": "Pel√© (athlete) ‚öΩ",
    "Mexico": "Frida Kahlo (artist) üé®",
    "Peru": "Mario Vargas Llosa (writer) üìö"
  };

  const SYMBOLISM_ONE_LINER = {
    "Peru": "Red honors sacrifice in the independence struggle; white stands for peace/purity.",
    "Iran": "Green/white/red are tied to growth/peace/courage; emblem/pattern reference Islamic identity.",
    "Japan": "Red sun disc represents the sun‚ÄîJapan as the ‚Äòland of the rising sun.‚Äô",
    "France": "Tricolor tied to the Revolution; often read as liberty/equality/fraternity."
  };

  function rjSlugForCountry(name){
    const slug = name.toLowerCase()
      .replace(/‚Äô/g,'')
      .replace(/'/g,'')
      .replace(/&/g,'and')
      .replace(/[^a-z0-9 ]/g,'')
      .trim()
      .replace(/\s+/g, '-');
    return `https://www.rjtravelagency.com/flag-of-${slug}/`;
  }

  function symbolismBlock(c){
    const name = c.name.common;
    const one = SYMBOLISM_ONE_LINER[name];
    const url = rjSlugForCountry(name);
    return one
      ? `<b>Flag meaning</b>: ${one}`
      : `‚ÑπÔ∏è <a href="${url}" target="_blank" rel="noopener">Learn more about this flag</a>`;
  }

  function hint1Food(c){
    const name = c.name.common;
    if (FOOD_HINT[name]) return FOOD_HINT[name];

    const cont = continentLabel(c.region, c.subregion);
    const fallback = {
      "Europe": "cheese + bread + something fermented üßÄü•ñ",
      "Asia": "noodles/rice + a signature spice combo üçúüçö",
      "Africa": "stews + grains + slow-cooked magic üç≤",
      "North America": "BBQ or tacos‚Ä¶ possibly both üî•üåÆ",
      "Central America": "beans + rice + coffee fuel ‚òïüçõ",
      "Caribbean": "jerk seasoning + tropical fruit ü•≠üå∂Ô∏è",
      "South America": "grilled meats + corn things ü•©üåΩ",
      "Oceania": "BBQ + beach picnic energy üèñÔ∏èü•©",
      "Other": "mystery snacks from a parallel universe ü•™üßÅ"
    };
    return fallback[cont] || fallback["Other"];
  }

  function hintForTry(c, tryUsed){
    // One-hint mode: only use the "tryUsed === 1" hint content.
    const cont = continentLabel(c.region, c.subregion);
    return [
      `¬∑ <b>Continent</b>: ${cont} üåç`,
      `¬∑ <b>Food</b>: ${hint1Food(c)}`
    ].join('<br/>');
  }

  function renderFlag() {
    closeSuggest();
    const c = currentCountry();
    if (!c) return;

    const url = c.flags?.png || c.flags?.svg || '';
    flagImg.src = url;
    flagImg.alt = `Flag of ${c.name?.common || 'Unknown'}`;

    triesLeft = TRIES_PER_FLAG;
    guessInput.value = '';
    guessInput.focus();
    updateHUD();

    renderMsg('go',"LET'S GO!",'', `Type a country name.`);
  }

  function pointsForTry(tryNumberUsed) {
    if (tryNumberUsed === 1) return 3;
    if (tryNumberUsed === 2) return 2;
    if (tryNumberUsed === 3) return 1;
    return 0;
  }

  // UPDATED: Press '.' once to show exactly one hint, then reveal the answer and advance.
  function consumeTryWithHint() {
    const c = currentCountry();
    if (!c) return;

    // Allow hint only at the very start of a flag (prevents multiple hints / spam)
    if (triesLeft !== TRIES_PER_FLAG) return;

    const hint = hintForTry(c, 1);

    renderMsg(
      'hint',
      'PSSST!',
      `Hint (only one!)`,
      `${hint}<br/><br/>Revealing answer in <b>${Math.round(PAUSE_WRONG_MS/1000)}s</b>‚Ä¶`
    );

    // Small beat so the hint is seen, then show the answer + schedule next flag
    setTimeout(() => {
      renderMsg(
        'fail',
        'OH NAWR!',
        `Answer: <b>${c.name.common}</b>.`,
        `${symbolismBlock(c)}<br/><br/>Next flag in <b>${Math.round(PAUSE_WRONG_MS/1000)}s</b>‚Ä¶`
      );
      setTimeout(() => advanceFlag(), PAUSE_WRONG_MS);
    }, 250);
  }

  /* =============================================================================================
     SECTION 7: CONFETTI + ROUND TRANSITION (unchanged)
  ============================================================================================= */
  function confettiBurst(ms=3000){
    const dpr = window.devicePixelRatio || 1;
    const w = Math.floor(window.innerWidth * dpr);
    const h = Math.floor(window.innerHeight * dpr);

    confettiCanvas.width = w;
    confettiCanvas.height = h;

    const ctx = confettiCanvas.getContext('2d');
    const pieces = [];
    const colors = ['#ff6b6b','#ffd93d','#6bcBef','#6bff95','#b36bff','#ff9f43'];

    const count = 520;

    for (let i=0;i<count;i++){
      pieces.push({
        x: Math.random()*w,
        y: -60 - Math.random()*h*0.35,
        vx: (Math.random()*2-1) * dpr * 0.9,
        vy: (Math.random()*1+0.9) * dpr * 1.25,
        r: (Math.random()*4+3) * dpr,
        rot: Math.random()*Math.PI,
        vr: (Math.random()*0.14-0.07),
        c: colors[Math.floor(Math.random()*colors.length)],
        life: Math.random()*0.65 + 0.35
      });
    }

    confettiLayer.style.display = 'block';

    const start = performance.now();
    function tick(t){
      const p = Math.min(1, (t-start)/ms);
      ctx.clearRect(0,0,w,h);

      const fade = Math.max(0, 1 - p);

      for (const s of pieces){
        s.x += s.vx;
        s.y += s.vy;
        s.rot += s.vr;

        s.vy += 0.010 * dpr;
        s.vx *= 0.996;
        s.vy *= 0.999;

        const alpha = Math.max(0, fade * s.life);

        ctx.save();
        ctx.translate(s.x, s.y);
        ctx.rotate(s.rot);
        ctx.globalAlpha = alpha;
        ctx.fillStyle = s.c;
        ctx.fillRect(-s.r, -s.r, s.r*2.2, s.r*1.2);
        ctx.restore();
      }

      if (p < 1) requestAnimationFrame(tick);
      else confettiLayer.style.display = 'none';
    }
    requestAnimationFrame(tick);
  }

  function roundTransition(nextRoundNumber){
    roundOverlayText.textContent = `ROUND ${nextRoundNumber}`;
    roundBurst.innerHTML = burstSVG('round', `ROUND ${nextRoundNumber}`);
    roundBurst.classList.remove('show');
    void roundBurst.offsetWidth;
    roundBurst.classList.add('show');

    roundOverlay.style.display = 'grid';
    confettiBurst(3000);

    setTimeout(() => {
      roundOverlay.style.display = 'none';
      renderFlag();
    }, 1550);
  }

  function advanceFlag() {
    flagIdx++;
    if (flagIdx >= FLAGS_PER_ROUND) {
      roundIdx++;
      flagIdx = 0;

      if (roundIdx >= rounds.length) {
        renderMsg('success','BOOM!',`üèÅ Game complete! Final score: <b>${score}</b> üéâ`, `Hit RESTART to play again.`);
        submitBtn.disabled = true;
        skipBtn.disabled = true;
        guessInput.disabled = true;
        updateHUD();
        return;
      }

      updateHUD();
      roundTransition(roundIdx + 1);
      return;
    }

    renderFlag();
  }

  function consumeTryWithHint() {
    const c = currentCountry();
    if (!c) return;
    if (triesLeft <= 0) return;

    const tryUsed = TRIES_PER_FLAG - triesLeft + 1;
    const hint = hintForTry(c, tryUsed);

    triesLeft--;
    updateHUD();

    if (triesLeft <= 0) {
      renderMsg(
        'fail',
        'OH NAWR!',
        `Out of tries! Answer: <b>${c.name.common}</b>.`,
        `${symbolismBlock(c)}<br/><br/>Next flag in <b>${Math.round(PAUSE_WRONG_MS/1000)}s</b>‚Ä¶`
      );
      setTimeout(() => advanceFlag(), PAUSE_WRONG_MS);
      return;
    }

    renderMsg(
      'hint',
      'PSSST!',
      `Hint Used (costs a try!)`,
      `${hint}<br/><br/>You have <b>${triesLeft}</b> tries left.`
    );
  }

  function submitGuess() {
    const c = currentCountry();
    if (!c) return;

    applySuggestionSelectionToInput();

    const guess = guessInput.value;
    const guessN = norm(guess);
    const accepted = currentAcceptedNames(c);
    const tryUsed = TRIES_PER_FLAG - triesLeft + 1;

    if (guessN && accepted.has(guessN)) {
      const pts = pointsForTry(tryUsed);
      score += pts;
      updateHUD();

      const emoji = pick(["üéâ","ü•≥","‚ú®"]);
      renderMsg(
        'success',
        'BOOM!',
        `Correct! That was <b>${c.name.common}</b>. ${emoji}`,
        `You earned <b>${pts}</b> point${pts === 1 ? '' : 's'}.<br/><br/>Next flag in <b>${Math.round(PAUSE_CORRECT_MS/1000)}s</b>‚Ä¶`
      );
      setTimeout(() => advanceFlag(), PAUSE_CORRECT_MS);
      return;
    }

    triesLeft--;
    updateHUD();

    if (triesLeft <= 0) {
      renderMsg(
        'fail',
        'OH NAWR!',
        `Nope. Answer: <b>${c.name.common}</b>.`,
        `${symbolismBlock(c)}<br/><br/>Next flag in <b>${Math.round(PAUSE_WRONG_MS/1000)}s</b>‚Ä¶`
      );
      setTimeout(() => advanceFlag(), PAUSE_WRONG_MS);
      return;
    }

    renderMsg(
      'fail',
      'OH NAWR!',
      `Not quite.`,
      `Try again. You have <b>${triesLeft}</b> tries left. (Hit <b>.</b> for a hint ‚Äî it costs a try.)`
    );

    guessInput.select();
    guessInput.focus();
  }

  function skipFlag() {
    const c = currentCountry();
    if (!c) return;

    renderMsg(
      'default',
      "LET'S GO!",
      `Skipped. Answer: <b>${c.name.common}</b>.`,
      `${symbolismBlock(c)}<br/><br/>Next flag in <b>${Math.round(PAUSE_WRONG_MS/1000)}s</b>‚Ä¶`
    );
    setTimeout(() => advanceFlag(), PAUSE_WRONG_MS);
  }

  function restart() {
    roundIdx = 0;
    flagIdx = 0;
    triesLeft = TRIES_PER_FLAG;
    score = 0;
    submitBtn.disabled = false;
    skipBtn.disabled = false;
    guessInput.disabled = false;
    renderFlag();
  }

  /* =============================================================================================
     SECTION 8: ROUND BUILDING (unchanged)
  ============================================================================================= */
  const WELL_KNOWN = new Set([
    'United States','Canada','Mexico','Brazil','Argentina','Chile','Colombia','Peru',
    'United Kingdom','Ireland','France','Spain','Portugal','Italy','Germany','Netherlands','Belgium','Switzerland','Austria','Sweden','Norway','Denmark','Finland','Iceland',
    'Russia','Ukraine','Poland','Czechia','Greece','Turkey',
    'China','Japan','South Korea','India','Pakistan','Bangladesh','Sri Lanka','Thailand','Vietnam','Indonesia','Philippines','Malaysia','Singapore',
    'Australia','New Zealand',
    'Egypt','South Africa','Nigeria','Kenya','Ethiopia','Ghana','Morocco','Tunisia',
    'Saudi Arabia','United Arab Emirates','Qatar','Iran','Iraq','Israel','Jordan','Lebanon','Syria'
  ]);

  function familiarityScore(c) {
    const pop = Math.max(0, c.population || 0);
    const popScore = Math.log10(pop + 1);
    const knownBoost = WELL_KNOWN.has(c.name.common) ? 6 : 0;
    return popScore + knownBoost;
  }

  function buildRoundsSmart(countries) {
    const scored = countries.map(c => ({ c, ease: familiarityScore(c) }));
    scored.sort((a,b) => b.ease - a.ease);

    const totalPossibleRounds = Math.floor(scored.length / FLAGS_PER_ROUND);
    const roundsCount = Math.max(6, Math.min(12, totalPossibleRounds));
    const bandSize = Math.floor(scored.length / roundsCount);

    const out = [];
    for (let r = 0; r < roundsCount; r++) {
      const start = r * bandSize;
      const end = (r === roundsCount - 1) ? scored.length : (r + 1) * bandSize;
      const band = scored.slice(start, end).map(x => x.c);
      shuffle(band);
      out.push(band.slice(0, FLAGS_PER_ROUND));
    }
    return out;
  }

/* =============================================================================================
   SECTION 9: HEADER FLAGS (LOCKED WINNER) + TWEAKS ONLY
   LOCKED: Outline flags approach that produced the winning result (DO NOT TOUCH).
   Tweaks:
   - ~3x more flags (still 10% colored)
   - Remove footer flags (top only)
============================================================================================= */
let FLAGFIELD_ITEMS = null;

// Fixed per your spec for the flag field layer
const FLAG_W = 40;
const FLAG_H = 25;

// Outline cache: url -> dataURL (png)
const OUTLINE_CACHE = new Map();
// In-flight loads: url -> Promise<dataURL|null>
const OUTLINE_INFLIGHT = new Map();

function buildFlagFields() {
  if (!countries.length) return;

  const topEl = flagFieldTopSvg;

  const w = Math.max(1400, window.innerWidth);
  const h = Math.max(240, Math.round(document.querySelector('.flagField--top').getBoundingClientRect().height));

  topEl.setAttribute('viewBox', `0 0 ${w} ${h}`);

  if (!FLAGFIELD_ITEMS || FLAGFIELD_ITEMS.w !== w || FLAGFIELD_ITEMS.h !== h) {
    // TWEAK ONLY: ~3x more flags
    const baseCount = Math.floor((w * h) / 6800);
    const count = Math.max(1, baseCount * 3);

    const items = [];

    const coloredCount = Math.max(1, Math.floor(count * 0.10));
    const coloredIdx = new Set();
    while (coloredIdx.size < coloredCount) coloredIdx.add(Math.floor(Math.random() * count));

    for (let i = 0; i < count; i++) {
      const c = countries[Math.floor(Math.random() * countries.length)];
      const url = (c.flags && (c.flags.svg || c.flags.png)) || '';
      if (!url) continue;

      const x = Math.random() * (w - (FLAG_W + 6));
      const y = Math.random() * (h - (FLAG_H + 6));
      const rot = (Math.random() * 10 - 5);

      items.push({ url, x, y, rot, colored: coloredIdx.has(i) });
    }

    // Ensure ‚Äútop occludes bottom‚Äù by drawing back-to-front in y-order
    items.sort((a, b) => a.y - b.y);

    FLAGFIELD_ITEMS = { w, h, items };
  }

  // Kick off outline generation (non-blocking). When each finishes, we re-render.
  primeOutlineCache_(FLAGFIELD_ITEMS.items);

  // Top only (footer removed)
  topEl.innerHTML = flagFieldSVGMarkup(FLAGFIELD_ITEMS.items, FLAGFIELD_ITEMS.w, FLAGFIELD_ITEMS.h, false);
}

function primeOutlineCache_(items) {
  for (const it of items) {
    if (it.colored) continue;
    const url = it.url;
    if (!url) continue;
    if (OUTLINE_CACHE.has(url)) continue;
    if (OUTLINE_INFLIGHT.has(url)) continue;

    const p = getOutlineDataUrl_(url)
      .then((dataUrl) => {
        if (dataUrl) OUTLINE_CACHE.set(url, dataUrl);
      })
      .catch(() => {})
      .finally(() => {
        OUTLINE_INFLIGHT.delete(url);
        // Re-render once we have more outlines ready.
        // (Safe: only affects section 9 visuals.)
        if (FLAGFIELD_ITEMS) {
          flagFieldTopSvg.innerHTML = flagFieldSVGMarkup(FLAGFIELD_ITEMS.items, FLAGFIELD_ITEMS.w, FLAGFIELD_ITEMS.h, false);
        }
      });

    OUTLINE_INFLIGHT.set(url, p);
  }
}

function flagFieldSVGMarkup(items, w, h, mirrorY) {
  const mirrorOpen = mirrorY ? `<g transform="translate(0 ${h}) scale(1 -1)">` : `<g>`;
  const mirrorClose = `</g>`;

  const defs = `
    <defs>
      <filter id="flagShadow" x="-40%" y="-40%" width="200%" height="200%">
        <feDropShadow dx="0" dy="1.5" stdDeviation="1.6" flood-color="rgba(0,0,0,0.12)"/>
      </filter>
    </defs>
  `;

  let out = `${defs}${mirrorOpen}`;

  for (const it of items) {
    const href = it.colored
      ? it.url
      : (OUTLINE_CACHE.get(it.url) || it.url); // fallback to real flag while outline loads

    // Colored flags: keep exactly as-is (your ‚Äúperfect‚Äù state)
    // Outline flags: once cached, href becomes transparent-background line-art PNG
    const opacity = it.colored ? 0.50 : (OUTLINE_CACHE.has(it.url) ? 0.90 : 0.18);

    out += `
      <g transform="translate(${it.x.toFixed(1)},${it.y.toFixed(1)}) rotate(${it.rot.toFixed(2)})" filter="url(#flagShadow)">
        <image href="${href}" width="${FLAG_W}" height="${FLAG_H}" opacity="${opacity}" preserveAspectRatio="none"></image>
      </g>
    `;
  }

  out += `${mirrorClose}`;
  return out;
}

function getOutlineDataUrl_(url) {
  return new Promise((resolve) => {
    const img = new Image();
    img.crossOrigin = 'anonymous';

    img.onload = () => {
      try {
        const dataUrl = makeOutlineDataUrl_(img);
        resolve(dataUrl);
      } catch (e) {
        // Canvas may be tainted if CORS fails; fallback to null
        resolve(null);
      }
    };

    img.onerror = () => resolve(null);
    img.src = url;
  });
}

/**
 * Convert a full-color flag image into transparent-background grey line-art,
 * preserving recognizable internal details, and avoiding the ‚Äúouter rectangle‚Äù artifact.
 *
 * Key rules:
 * 1) Outer-most perimeter pixels are forced fully transparent (kills the rectangle).
 * 2) A thin INNER border is drawn (x==1 || y==1 || x==W-2 || y==H-2) in light grey.
 * 3) The rest uses an edge-ish stencil (simple gradient magnitude) -> alpha.
 */
function makeOutlineDataUrl_(img) {
  const canvas = document.createElement('canvas');
  canvas.width = FLAG_W;
  canvas.height = FLAG_H;

  const ctx = canvas.getContext('2d', { willReadFrequently: true });
  ctx.clearRect(0, 0, FLAG_W, FLAG_H);

  // Draw scaled into our exact 40x25 box
  ctx.drawImage(img, 0, 0, FLAG_W, FLAG_H);

  const W = FLAG_W, H = FLAG_H;
  const src = ctx.getImageData(0, 0, W, H);
  const s = src.data;

  // Luma buffer
  const lum = new Float32Array(W * H);
  for (let y = 0; y < H; y++) {
    for (let x = 0; x < W; x++) {
      const i = (y * W + x) * 4;
      const r = s[i], g = s[i + 1], b = s[i + 2];
      lum[y * W + x] = 0.2126 * r + 0.7152 * g + 0.0722 * b;
    }
  }

  // Output
  const out = ctx.createImageData(W, H);
  const o = out.data;

  // Helper: clamp
  const clamp01 = (v) => (v < 0 ? 0 : v > 1 ? 1 : v);

  for (let y = 0; y < H; y++) {
    for (let x = 0; x < W; x++) {
      const p = y * W + x;
      const idx = p * 4;

      // 1) HARD KILL PERIMETER: removes the unwanted outer rectangle artifact
      if (x === 0 || y === 0 || x === W - 1 || y === H - 1) {
        o[idx] = o[idx + 1] = o[idx + 2] = 0;
        o[idx + 3] = 0;
        continue;
      }

      // 2) INNER BORDER: thin grey ‚Äúflag frame‚Äù without creating an outer rectangle
      if (x === 1 || y === 1 || x === W - 2 || y === H - 2) {
        o[idx]     = 138; // light grey
        o[idx + 1] = 146;
        o[idx + 2] = 156;
        o[idx + 3] = 120; // alpha
        continue;
      }

      // 3) Simple edge magnitude using central differences
      const xm1 = x - 1, xp1 = x + 1;
      const ym1 = y - 1, yp1 = y + 1;

      const Lx = lum[y * W + xp1] - lum[y * W + xm1];
      const Ly = lum[yp1 * W + x] - lum[ym1 * W + x];

      // Normalize-ish: empirical scaling for tiny 40x25
      const mag = Math.sqrt(Lx * Lx + Ly * Ly) / 255;

      // Threshold to keep detail, but avoid ‚Äúboxy fill‚Äù
      let a = (mag - 0.08) / 0.28; // shift + scale
      a = clamp01(a);

      const alpha = Math.round(a * 140); // overall line strength

      if (alpha <= 0) {
        o[idx] = o[idx + 1] = o[idx + 2] = 0;
        o[idx + 3] = 0;
      } else {
        o[idx]     = 138; // light grey ink
        o[idx + 1] = 146;
        o[idx + 2] = 156;
        o[idx + 3] = alpha;
      }
    }
  }

  // Write + export
  ctx.clearRect(0, 0, W, H);
  ctx.putImageData(out, 0, 0);

  return canvas.toDataURL('image/png');
}

  /* =============================================================================================
     SECTION 10: EVENTS (unchanged)
  ============================================================================================= */
  submitBtn.addEventListener('click', submitGuess);
  skipBtn.addEventListener('click', skipFlag);
  restartBtnTop.addEventListener('click', () => { restart(); });

  guessInput.addEventListener('input', (e) => renderSuggestions(e.target.value));
  guessInput.addEventListener('focus', () => { if (guessInput.value) renderSuggestions(guessInput.value); });

  document.addEventListener('mousedown', (e) => {
    const inWrap = e.target === guessInput || suggestBox.contains(e.target);
    if (!inWrap) closeSuggest();
  });

  guessInput.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowDown') { e.preventDefault(); moveActive(+1); return; }
    if (e.key === 'ArrowUp') { e.preventDefault(); moveActive(-1); return; }
    if (e.key === 'Escape') { closeSuggest(); return; }

    if (e.key === 'Enter') {
      e.preventDefault();
      if (suggestBox.style.display === 'block' && currentSuggestions.length) {
        applySuggestionSelectionToInput();
      }
      submitGuess();
      return;
    }
  });

  document.addEventListener('keydown', (e) => {
    if (e.key !== '.') return;
    if (e.metaKey || e.ctrlKey || e.altKey) return;
    const t = e.target;
    const isTextField = t && (t.tagName === 'INPUT' || t.tagName === 'TEXTAREA') && !t.readOnly && !t.disabled;
    if (isTextField) e.preventDefault();
    consumeTryWithHint();
    guessInput.focus();
  });

  /* =============================================================================================
     SECTION 11: BOOT
  ============================================================================================= */
  async function loadCountries() {
    const res = await fetch(
      'https://restcountries.com/v3.1/all?fields=name,flags,altSpellings,population,region,subregion,cca3,borders'
    );
    if (!res.ok) throw new Error(`Failed to fetch countries: ${res.status}`);

    const data = await res.json();

    countries = data
      .filter(c => c?.name?.common && (c?.flags?.png || c?.flags?.svg))
      .map(c => ({
        name: c.name,
        altSpellings: c.altSpellings || [],
        flags: c.flags,
        population: c.population || 0,
        region: c.region || '',
        subregion: c.subregion || '',
        cca3: c.cca3 || '',
        borders: Array.isArray(c.borders) ? c.borders : []
      }));

    cca3ToCountry = new Map();
    for (const c of countries) {
      if (c.cca3) cca3ToCountry.set(c.cca3, c);
    }

    rounds = buildRoundsSmart(countries);

    buildFlagFields();
    restart();
  }

  loadCountries().catch(err => {
    console.error(err);
    renderMsg('fail','OH NAWR!',`Couldn‚Äôt load country data.`, `${String(err.message || err)}`);
  });

  window.addEventListener('resize', () => {
    buildFlagFields();
  });
})();
</script>
</body>
</html>
